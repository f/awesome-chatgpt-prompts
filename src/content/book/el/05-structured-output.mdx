Η απόκτηση συνεπούς, καλά μορφοποιημένης εξόδου είναι απαραίτητη για εφαρμογές παραγωγής και αποδοτικές ροές εργασίας. Αυτό το κεφάλαιο καλύπτει τεχνικές για τον έλεγχο του ακριβώς πώς τα μοντέλα AI μορφοποιούν τις απαντήσεις τους.

<Callout type="info" title="Από Πεζό Λόγο σε Δεδομένα">
Η δομημένη έξοδος μετατρέπει τις απαντήσεις AI από ελεύθερο κείμενο σε πρακτικά, αναλύσιμα δεδομένα.
</Callout>

## Γιατί Έχει Σημασία η Δομή

<StructuredOutputDemo />

## Βασικές Τεχνικές Μορφοποίησης

### Λίστες

Οι λίστες είναι τέλειες για οδηγίες βήμα-βήμα, κατατεταγμένα στοιχεία, ή συλλογές σχετικών σημείων. Είναι εύκολο να σαρωθούν και να αναλυθούν. Χρησιμοποιήστε **αριθμημένες λίστες** όταν η σειρά έχει σημασία (βήματα, κατατάξεις) και **κουκκίδες** για μη ταξινομημένες συλλογές.

<TryIt 
  compact
  title="Μορφοποίηση Λίστας"
  prompt={`Δώσε 5 συμβουλές για καλύτερο ύπνο.

Μορφή: Αριθμημένη λίστα με σύντομη εξήγηση για κάθε μία.
Κάθε συμβουλή πρέπει να είναι έντονη, ακολουθούμενη από παύλα και εξήγηση.`}
/>

<Callout type="tip" title="Βέλτιστες Πρακτικές Λίστας">
Καθορίστε τον ακριβή αριθμό στοιχείων που θέλετε, αν θα συμπεριλάβετε εξηγήσεις, και αν τα στοιχεία πρέπει να είναι έντονα ή να έχουν συγκεκριμένη δομή.
</Callout>

### Πίνακες

Οι πίνακες υπερέχουν στη σύγκριση πολλαπλών στοιχείων στις ίδιες διαστάσεις. Είναι ιδανικοί για συγκρίσεις χαρακτηριστικών, περιλήψεις δεδομένων, και οποιαδήποτε πληροφορία με συνεπή χαρακτηριστικά. Πάντα ορίζετε τις επικεφαλίδες στηλών ρητά.

<TryIt 
  compact
  title="Μορφοποίηση Πίνακα"
  prompt={`Σύγκρινε τα κορυφαία 4 Python web frameworks.

Μορφοποίησε ως πίνακα markdown με στήλες:
| Framework | Καλύτερο Για | Καμπύλη Μάθησης | Απόδοση |`}
/>

<Callout type="tip" title="Βέλτιστες Πρακτικές Πίνακα">
Καθορίστε ονόματα στηλών, αναμενόμενους τύπους δεδομένων (κείμενο, αριθμούς, βαθμολογίες), και πόσες σειρές χρειάζεστε. Για πολύπλοκες συγκρίσεις, περιορίστε σε 4-6 στήλες για αναγνωσιμότητα.
</Callout>

### Επικεφαλίδες και Ενότητες

Οι επικεφαλίδες δημιουργούν σαφή δομή εγγράφου, κάνοντας τις μεγάλες απαντήσεις σαρώσιμες και οργανωμένες. Χρησιμοποιήστε τες για αναφορές, αναλύσεις, ή οποιαδήποτε απάντηση πολλαπλών μερών. Οι ιεραρχικές επικεφαλίδες (##, ###) δείχνουν σχέσεις μεταξύ ενοτήτων.

```
Ανάλυσε αυτή την επιχειρηματική πρόταση.

Δόμησε την απάντησή σου με αυτές τις ενότητες:
## Εκτελεστική Σύνοψη
## Δυνατά Σημεία
## Αδυναμίες
## Συστάσεις
## Αξιολόγηση Κινδύνου
```

<Callout type="tip" title="Βέλτιστες Πρακτικές Ενοτήτων">
Κατονομάστε τις ενότητές σας στη σειρά που τις θέλετε. Για συνέπεια, καθορίστε τι πρέπει να περιέχει κάθε ενότητα (π.χ., "Εκτελεστική Σύνοψη: μόνο 2-3 προτάσεις").
</Callout>

### Έμφαση με Οδηγίες Κεφαλαίων

Οι λέξεις με κεφαλαία λειτουργούν ως ισχυρά σήματα στο μοντέλο, τονίζοντας κρίσιμους περιορισμούς ή απαιτήσεις. Χρησιμοποιήστε τες με φειδώ για μέγιστο αντίκτυπο—η υπερβολική χρήση αραιώνει την αποτελεσματικότητά τους.

**Κοινές Οδηγίες Κεφαλαίων:**

<InfoGrid items={[
  { label: "ΠΟΤΕ", description: "Απόλυτη απαγόρευση: \"ΠΟΤΕ μην συμπεριλαμβάνεις προσωπικές απόψεις\"", color: "red" },
  { label: "ΠΑΝΤΑ", description: "Υποχρεωτική απαίτηση: \"ΠΑΝΤΑ αναφέρε πηγές\"", color: "green" },
  { label: "ΣΗΜΑΝΤΙΚΟ", description: "Κρίσιμη οδηγία: \"ΣΗΜΑΝΤΙΚΟ: Κράτα τις απαντήσεις κάτω από 100 λέξεις\"", color: "amber" },
  { label: "ΜΗΝ", description: "Ισχυρή απαγόρευση: \"ΜΗΝ επινοείς στατιστικά\"", color: "red" },
  { label: "ΠΡΕΠΕΙ", description: "Απαιτούμενη ενέργεια: \"Η έξοδος ΠΡΕΠΕΙ να είναι έγκυρο JSON\"", color: "blue" },
  { label: "ΜΟΝΟ", description: "Περιορισμός: \"Επέστρεψε ΜΟΝΟ τον κώδικα, χωρίς εξηγήσεις\"", color: "purple" },
]} />

```
Συνόψισε αυτό το άρθρο.

ΣΗΜΑΝΤΙΚΟ: Κράτα τη σύνοψη κάτω από 100 λέξεις.
ΠΟΤΕ μην προσθέτεις πληροφορίες που δεν υπάρχουν στο πρωτότυπο.
ΠΑΝΤΑ διατήρησε τον αρχικό τόνο και προοπτική.
ΜΗΝ συμπεριλαμβάνεις τις δικές σου απόψεις ή ανάλυση.
```

<Callout type="warning" title="Χρησιμοποίησε με Φειδώ">
Αν όλα είναι με κεφαλαία ή επισημασμένα ως κρίσιμα, τίποτα δεν ξεχωρίζει. Κράτησε αυτές τις οδηγίες για πραγματικά σημαντικούς περιορισμούς.
</Callout>

## Έξοδος JSON

Το JSON (JavaScript Object Notation) είναι η πιο δημοφιλής μορφή για δομημένη έξοδο AI. Είναι αναγνώσιμο από μηχανές, ευρέως υποστηριζόμενο από γλώσσες προγραμματισμού, και τέλειο για APIs, βάσεις δεδομένων, και ροές εργασίας αυτοματισμού. Το κλειδί για αξιόπιστο JSON είναι η παροχή σαφούς schema.

### Βασικό Αίτημα JSON

Ξεκινήστε με ένα template που δείχνει την ακριβή δομή που θέλετε. Συμπεριλάβετε ονόματα πεδίων, τύπους δεδομένων, και παραδείγματα τιμών. Αυτό λειτουργεί ως συμβόλαιο που θα ακολουθήσει το μοντέλο.

<TryIt 
  title="Εξαγωγή JSON"
  description="Εξαγάγετε δομημένα δεδομένα από μη δομημένο κείμενο."
  prompt={`Εξαγάγε πληροφορίες από αυτό το κείμενο και επέστρεψε ως JSON:

{
    "company_name": "string",
    "founding_year": number,
    "headquarters": "string",
    "employees": number,
    "industry": "string"
}

Κείμενο: "Η Apple Inc., που ιδρύθηκε το 1976, έχει έδρα στο Cupertino της Καλιφόρνια. Ο τεχνολογικός κολοσσός απασχολεί περίπου 164.000 άτομα παγκοσμίως."`}
/>

### Πολύπλοκες Δομές JSON

Για ένθετα δεδομένα, χρησιμοποιήστε ιεραρχικό JSON με αντικείμενα μέσα σε αντικείμενα, πίνακες αντικειμένων, και μικτούς τύπους. Ορίστε κάθε επίπεδο ξεκάθαρα και χρησιμοποιήστε annotations τύπου TypeScript (`"positive" | "negative"`) για να περιορίσετε τιμές.

```
Ανάλυσε αυτή την κριτική προϊόντος και επέστρεψε JSON:

{
  "review_id": "string (δημιούργησε μοναδικό)",
  "sentiment": {
    "overall": "positive" | "negative" | "mixed" | "neutral",
    "score": 0.0-1.0
  },
  "aspects": [
    {
      "aspect": "string (π.χ., 'τιμή', 'ποιότητα')",
      "sentiment": "positive" | "negative" | "neutral",
      "mentions": ["ακριβή αποσπάσματα από κριτική"]
    }
  ],
  "purchase_intent": {
    "would_recommend": boolean,
    "confidence": 0.0-1.0
  },
  "key_phrases": ["string array αξιοσημείωτων φράσεων"]
}

Επέστρεψε ΜΟΝΟ έγκυρο JSON, χωρίς επιπλέον κείμενο.

Κριτική: "[κείμενο κριτικής]"
```

### Εξασφάλιση Έγκυρου JSON

Τα μοντέλα μερικές φορές προσθέτουν επεξηγηματικό κείμενο ή μορφοποίηση markdown γύρω από το JSON. Αποτρέψτε αυτό με ρητές οδηγίες για τη μορφή εξόδου. Μπορείτε να ζητήσετε raw JSON ή JSON μέσα σε code blocks—επιλέξτε βάσει των αναγκών ανάλυσής σας.

Προσθέστε ρητές οδηγίες:

```
ΣΗΜΑΝΤΙΚΟ:
- Επέστρεψε ΜΟΝΟ το αντικείμενο JSON, χωρίς markdown code blocks
- Βεβαιώσου ότι όλα τα strings είναι σωστά escaped
- Χρησιμοποίησε null για ελλείπουσες τιμές, όχι undefined
- Επαλήθευσε ότι η έξοδος είναι αναλύσιμο JSON
```

Ή ζητήστε code blocks ζητώντας από το μοντέλο να περιτυλίξει την έξοδό του:

````
Επέστρεψε το αποτέλεσμα ως JSON code block:
```json
{ ... }
```
````

## Έξοδος YAML

Το YAML είναι πιο αναγνώσιμο από ανθρώπους από το JSON, χρησιμοποιώντας εσοχή αντί για αγκύλες. Είναι το standard για αρχεία διαμόρφωσης (Docker, Kubernetes, GitHub Actions) και λειτουργεί καλά όταν η έξοδος θα διαβαστεί από ανθρώπους ή θα χρησιμοποιηθεί σε DevOps πλαίσια. Το YAML είναι ευαίσθητο στην εσοχή, οπότε να είστε συγκεκριμένοι για τις απαιτήσεις μορφοποίησης.

<TryIt 
  compact
  title="Δημιουργία YAML"
  prompt={`Δημιούργησε ένα GitHub Actions workflow για ένα Node.js project.

Επέστρεψε ως έγκυρο YAML:
- Συμπερίλαβε: install, lint, test, build στάδια
- Χρησιμοποίησε Node.js 18
- Cache npm dependencies
- Εκτέλεση σε push στο main και pull requests`}
/>

## Έξοδος XML

Το XML απαιτείται ακόμα για πολλά enterprise συστήματα, SOAP APIs, και legacy ενσωματώσεις. Είναι πιο εκτενές από το JSON αλλά προσφέρει χαρακτηριστικά όπως attributes, namespaces, και CDATA sections για πολύπλοκα δεδομένα. Καθορίστε ονόματα στοιχείων, δομή ένθεσης, και πού να χρησιμοποιήσετε attributes έναντι child elements.

```
Μετάτρεψε αυτά τα δεδομένα σε μορφή XML:

Απαιτήσεις:
- Root element: <catalog>
- Κάθε στοιχείο σε <book> element
- Συμπερίλαβε attributes όπου ενδείκνυται
- Χρησιμοποίησε CDATA για κείμενο περιγραφής

Δεδομένα: [δεδομένα βιβλίου]
```

## Προσαρμοσμένες Μορφές

Μερικές φορές οι standard μορφές δεν ταιριάζουν στις ανάγκες σας. Μπορείτε να ορίσετε οποιαδήποτε προσαρμοσμένη μορφή παρέχοντας ένα σαφές template. Οι προσαρμοσμένες μορφές λειτουργούν καλά για αναφορές, logs, ή εξόδους ειδικού τομέα που θα διαβαστούν από ανθρώπους.

### Μορφή Δομημένης Ανάλυσης

Χρησιμοποιήστε διαχωριστές (===, ---, [SECTION]) για να δημιουργήσετε σαρώσιμα έγγραφα με σαφή όρια μεταξύ ενοτήτων. Αυτή η μορφή είναι εξαιρετική για αναθεωρήσεις κώδικα, ελέγχους, και αναλύσεις.

```
Ανάλυσε αυτόν τον κώδικα χρησιμοποιώντας αυτή την ακριβή μορφή:

=== ΑΝΑΛΥΣΗ ΚΩΔΙΚΑ ===

[ΣΥΝΟΨΗ]
Μία παράγραφος επισκόπηση

[ΠΡΟΒΛΗΜΑΤΑ]
• ΚΡΙΣΙΜΟ: [πρόβλημα] — [αρχείο:γραμμή]
• ΠΡΟΕΙΔΟΠΟΙΗΣΗ: [πρόβλημα] — [αρχείο:γραμμή]  
• ΠΛΗΡΟΦΟΡΙΑ: [πρόβλημα] — [αρχείο:γραμμή]

[ΜΕΤΡΙΚΕΣ]
Πολυπλοκότητα: [Χαμηλή/Μέση/Υψηλή]
Συντηρησιμότητα: [βαθμολογία]/10
Κάλυψη Δοκιμών: [εκτιμώμενο %]

[ΣΥΣΤΑΣΕΙΣ]
1. [Σύσταση προτεραιότητας 1]
2. [Σύσταση προτεραιότητας 2]

=== ΤΕΛΟΣ ΑΝΑΛΥΣΗΣ ===
```

### Μορφή Συμπλήρωσης Κενών

Τα templates με κενά (___) καθοδηγούν το μοντέλο να συμπληρώσει συγκεκριμένα πεδία διατηρώντας ακριβή μορφοποίηση. Αυτή η προσέγγιση είναι εξαιρετική για φόρμες, briefs, και τυποποιημένα έγγραφα όπου η συνέπεια έχει σημασία.

```
Συμπλήρωσε αυτό το template για το δοσμένο προϊόν:

PRODUCT BRIEF
─────────────
Όνομα: _______________
Tagline: _______________
Χρήστης-Στόχος: _______________
Πρόβλημα που Λύνει: _______________
Βασικά Χαρακτηριστικά:
  1. _______________
  2. _______________
  3. _______________
Διαφοροποίηση: _______________

Προϊόν: [περιγραφή προϊόντος]
```

## Τυποποιημένες Απαντήσεις

Οι τυποποιημένες απαντήσεις ορίζουν κατηγορίες ή τύπους οντοτήτων που πρέπει να αναγνωρίσει και να επισημάνει το μοντέλο. Αυτή η τεχνική είναι απαραίτητη για Named Entity Recognition (NER), εργασίες ταξινόμησης, και οποιαδήποτε εξαγωγή όπου χρειάζεται να κατηγοριοποιήσετε πληροφορίες συνεπώς. Ορίστε τους τύπους σας ξεκάθαρα με παραδείγματα.

<TryIt 
  compact
  title="Εξαγωγή Οντοτήτων"
  prompt={`Εξαγάγε οντότητες από αυτό το κείμενο.

Τύποι Οντοτήτων:
- ΠΡΟΣΩΠΟ: Πλήρη ονόματα ατόμων
- ΟΡΓΑΝΙΣΜΟΣ: Ονόματα οργανισμών/εταιρειών
- ΤΟΠΟΘΕΣΙΑ: Πόλεις, χώρες, διευθύνσεις
- ΗΜΕΡΟΜΗΝΙΑ: Ημερομηνίες σε μορφή ISO (YYYY-MM-DD)
- ΧΡΗΜΑΤΑ: Χρηματικά ποσά με νόμισμα

Μορφοποίησε κάθε μία ως: [ΤΥΠΟΣ]: [τιμή]

Κείμενο: "Ο Tim Cook ανακοίνωσε ότι η Apple θα επενδύσει 1 δισεκατομμύριο δολάρια σε νέα εγκατάσταση στο Austin μέχρι τον Δεκέμβριο 2024."`}
/>

## Multi-Part Structured Responses

When you need comprehensive output covering multiple aspects, define distinct parts with clear boundaries. Specify exactly what goes in each part—format, length, and content type. This prevents the model from blending sections or omitting parts.

```
Research this topic and provide:

### PART 1: EXECUTIVE SUMMARY
[2-3 sentence overview]

### PART 2: KEY FINDINGS
[Exactly 5 bullet points]

### PART 3: DATA TABLE
| Metric | Value | Source |
|--------|-------|--------|
[Include 5 rows minimum]

### PART 4: RECOMMENDATIONS
[Numbered list of 3 actionable recommendations]

### PART 5: FURTHER READING
[3 suggested resources with brief descriptions]
```

## Conditional Formatting

Conditional formatting lets you define different output formats based on the input's characteristics. This is powerful for classification, triage, and routing systems where the response format should vary based on what the model detects. Use clear if/then logic with explicit output templates for each case.

<TryIt 
  compact
  title="Ticket Classification"
  prompt={`Classify this support ticket.

If URGENT (system down, security issue, data loss):
  Return: 🔴 URGENT | [Category] | [Suggested Action]

If HIGH (affects multiple users, revenue impact):
  Return: 🟠 HIGH | [Category] | [Suggested Action]

If MEDIUM (single user affected, workaround exists):
  Return: 🟡 MEDIUM | [Category] | [Suggested Action]

If LOW (questions, feature requests):
  Return: 🟢 LOW | [Category] | [Suggested Action]

Ticket: "I can't login to my account. I've tried resetting my password twice but still getting an error. This is blocking my entire team from accessing the dashboard."`}
/>

## Arrays and Lists in JSON

Extracting multiple items into arrays requires careful schema definition. Specify the array structure, what each item should contain, and how to handle edge cases (empty arrays, single items). Including a count field helps verify completeness.

```
Extract all action items from this meeting transcript.

Return as JSON array:
{
  "action_items": [
    {
      "task": "string describing the task",
      "assignee": "person name or 'Unassigned'",
      "deadline": "date if mentioned, else null",
      "priority": "high" | "medium" | "low",
      "context": "relevant quote from transcript"
    }
  ],
  "total_count": number
}

Transcript: "[meeting transcript]"
```

## Validation Instructions

Self-validation prompts the model to check its own output before responding. This catches common issues like missing sections, placeholder text, or constraint violations. The model will iterate internally to fix problems, improving output quality without additional API calls.

```
Generate the report, then:

VALIDATION CHECKLIST:
□ All required sections present
□ No placeholder text remaining
□ All statistics include sources
□ Word count within 500-700 words
□ Conclusion ties back to introduction

If any check fails, fix before responding.
```

## Handling Optional Fields

Real-world data often has missing values. Explicitly instruct the model on how to handle optional fields—using `null` is cleaner than empty strings and easier to process programmatically. Also prevent "hallucination" of missing data by emphasizing that the model should never invent information.

```
Extract contact information. Use null for missing fields.

{
  "name": "string (required)",
  "email": "string or null",
  "phone": "string or null", 
  "company": "string or null",
  "role": "string or null",
  "linkedin": "URL string or null"
}

IMPORTANT: 
- Never invent information not in the source
- Use null, not empty strings, for missing data
- Phone numbers in E.164 format if possible
```

## Summary

<Callout type="tip" title="Key Techniques">
Be explicit about format, use examples, specify types, handle edge cases with null values, and ask the model to validate its own output.
</Callout>

<Quiz 
  question="What's the main advantage of structured output over unstructured text?"
  options={[
    "It uses fewer tokens",
    "It's easier for the AI to generate",
    "It can be parsed programmatically and validated",
    "It always produces correct information"
  ]}
  correctIndex={2}
  explanation="Structured outputs like JSON can be parsed by code, compared across queries, integrated into workflows, and validated for completeness—things that are difficult or impossible with freeform text."
/>

Structured outputs are essential for building reliable AI-powered applications. In the next chapter, we'll explore chain-of-thought prompting for complex reasoning tasks.
