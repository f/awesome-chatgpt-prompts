Capire il contesto è essenziale per costruire applicazioni IA che funzionano davvero. Questo capitolo copre tutto ciò che devi sapere per dare all'IA le informazioni giuste al momento giusto.

<Callout type="info" title="Perché il Contesto È Importante">
I modelli IA sono stateless. Non ricordano le conversazioni passate. Ogni volta che invii un messaggio, devi includere tutto ciò che l'IA deve sapere. Questo si chiama "context engineering."
</Callout>

## Cos'è il Contesto?

Il contesto è tutta l'informazione che dai all'IA insieme alla tua domanda. Pensala così:

<Compare 
  before={{ label: "Senza Contesto", content: "Qual è lo stato?" }}
  after={{ label: "Con Contesto", content: "Sei un assistente project manager. L'utente sta lavorando sul Progetto Alpha, con scadenza venerdì. L'ultimo aggiornamento era: 'Backend completo, frontend 80% fatto.'\n\nUtente: Qual è lo stato?" }}
/>

Senza contesto, l'IA non ha idea di quale "stato" stai chiedendo. Con contesto, può dare una risposta utile.

### La Finestra di Contesto

Ricorda dai capitoli precedenti: l'IA ha una "finestra di contesto" limitata - la quantità massima di testo che può vedere in una volta. Questa include:

<InfoGrid items={[
  { label: "System Prompt", description: "Istruzioni che definiscono il comportamento dell'IA", color: "purple" },
  { label: "Storico Conversazione", description: "Messaggi precedenti in questa chat", color: "blue" },
  { label: "Informazioni Recuperate", description: "Documenti, dati o conoscenza recuperati per questa query", color: "green" },
  { label: "Query Corrente", description: "La domanda vera dell'utente", color: "amber" },
  { label: "Risposta IA", description: "La risposta (conta anche verso il limite!)", color: "rose" },
]} />

## L'IA è Stateless

<Callout type="warning" title="Concetto Importante">
L'IA non ricorda nulla tra le conversazioni. Ogni chiamata API parte da zero. Se vuoi che l'IA "ricordi" qualcosa, DEVI includerlo nel contesto ogni volta.
</Callout>

Ecco perché i chatbot inviano l'intera cronologia della conversazione con ogni messaggio. Non è che l'IA ricorda - è che l'app re-invia tutto.

<TryIt compact prompt={`Fai finta che questa sia una nuova conversazione senza cronologia.

Di cosa ti ho appena chiesto?`} />

L'IA dirà che non lo sa perché veramente non ha accesso a nessun contesto precedente.

## RAG: Retrieval-Augmented Generation

RAG è una tecnica per dare all'IA accesso a conoscenza su cui non è stata addestrata. Invece di cercare di inserire tutto nell'addestramento dell'IA, tu:

1. **Memorizzi** i tuoi documenti in un database ricercabile
2. **Cerchi** documenti rilevanti quando un utente fa una domanda
3. **Recuperi** i pezzi più rilevanti
4. **Arricchisci** il tuo prompt con quei pezzi
5. **Generi** una risposta usando quel contesto

<div className="my-6 p-4 border rounded-lg bg-muted/30">
  <p className="font-semibold mb-3">Come Funziona RAG:</p>
  <div className="flex flex-col gap-2 text-sm">
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-blue-600 font-bold">1</span>
      <span>L'utente chiede: "Qual è la nostra politica di rimborso?"</span>
    </div>
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-blue-600 font-bold">2</span>
      <span>Il sistema cerca nei tuoi documenti "politica di rimborso"</span>
    </div>
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-blue-600 font-bold">3</span>
      <span>Trova la sezione rilevante dal tuo documento di policy</span>
    </div>
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-blue-600 font-bold">4</span>
      <span>Invia all'IA: "Basandoti su questa policy: [testo], rispondi: Qual è la nostra politica di rimborso?"</span>
    </div>
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 flex items-center justify-center text-green-600 font-bold">5</span>
      <span>L'IA genera una risposta accurata usando la tua policy reale</span>
    </div>
  </div>
</div>

### Perché RAG?

<div className="my-6 grid md:grid-cols-2 gap-4">
  <div className="p-4 border rounded-lg">
    <p className="font-semibold text-green-600 dark:text-green-400 mb-2 flex items-center gap-2"><IconCheck className="text-green-600" /> Vantaggi RAG</p>
    <ul className="text-sm space-y-1 text-muted-foreground">
      <li>Usa i tuoi dati reali e attuali</li>
      <li>Riduce le allucinazioni</li>
      <li>Può citare le fonti</li>
      <li>Facile da aggiornare (basta aggiornare i documenti)</li>
      <li>Nessun fine-tuning costoso necessario</li>
    </ul>
  </div>
  <div className="p-4 border rounded-lg">
    <p className="font-semibold text-amber-600 dark:text-amber-400 mb-2 flex items-center gap-2"><IconLightbulb className="text-amber-600" /> Quando Usare RAG</p>
    <ul className="text-sm space-y-1 text-muted-foreground">
      <li>Bot di supporto clienti</li>
      <li>Ricerca documentazione</li>
      <li>Basi di conoscenza interne</li>
      <li>Qualsiasi Q&A specifico per dominio</li>
      <li>Quando l'accuratezza conta</li>
    </ul>
  </div>
</div>

## Embeddings: Come Funziona la Ricerca

Come fa RAG a sapere quali documenti sono "rilevanti"? Usa gli **embeddings** - un modo per trasformare il testo in numeri che catturano il significato.

### Cosa Sono gli Embeddings?

Un embedding è una lista di numeri (un "vettore") che rappresenta il significato del testo. Significati simili = numeri simili.

<EmbeddingsDemo />

### Ricerca Semantica

Con gli embeddings, puoi cercare per significato, non solo per parole chiave:

<Compare 
  before={{ label: "Ricerca per Parole Chiave", content: "Query: 'politica reso'\nTrova: Documenti contenenti 'politica' e 'reso'\nManca: 'Come ottenere un rimborso'" }}
  after={{ label: "Ricerca Semantica", content: "Query: 'politica reso'\nTrova: Tutti i documenti correlati inclusi:\n- 'Linee guida rimborso'\n- 'Come restituire gli articoli'\n- 'Garanzia soddisfatti o rimborsati'" }}
/>

Ecco perché RAG è così potente - trova informazioni rilevanti anche quando le parole esatte non corrispondono.

## Function Calling / Tool Use

Il function calling permette all'IA di usare strumenti esterni - come cercare sul web, interrogare un database, o chiamare un'API.

<Callout type="tip" title="Chiamato Anche">
Diversi provider IA lo chiamano in modi diversi: "function calling" (OpenAI), "tool use" (Anthropic/Claude), o "tools" (termine generale). Significano tutti la stessa cosa.
</Callout>

### Come Funziona

1. Dici all'IA quali strumenti sono disponibili
2. L'IA decide se ha bisogno di uno strumento per rispondere
3. L'IA produce una richiesta strutturata per lo strumento
4. Il tuo codice esegue lo strumento e restituisce i risultati
5. L'IA usa i risultati per formare la sua risposta

<TryIt 
  title="Esempio Function Calling"
  description="Questo prompt mostra come l'IA decide di usare uno strumento:"
  prompt={`Hai accesso a questi strumenti:

1. get_weather(city: string) - Ottieni il meteo attuale per una città
2. search_web(query: string) - Cerca su internet
3. calculate(expression: string) - Fai calcoli matematici

Utente: Com'è il tempo a Tokyo adesso?

Pensa passo passo: Hai bisogno di uno strumento? Quale? Quali parametri?`}
/>

## Riassunto: Gestire Conversazioni Lunghe

Man mano che le conversazioni si allungano, raggiungerai il limite della finestra di contesto. Poiché l'IA è stateless (non ricorda nulla), conversazioni lunghe possono traboccare. La soluzione? **Riassunto**.

### Il Problema

<Compare 
  before={{ label: "Senza Riassunto", content: "Messaggio 1 (500 token)\nMessaggio 2 (800 token)\nMessaggio 3 (600 token)\n... altri 50 messaggi ...\n────────────────────\n= 40.000+ token\n= OLTRE IL LIMITE!" }}
  after={{ label: "Con Riassunto", content: "[Riassunto]: 200 token\nMessaggi recenti: 2.000 token\nQuery corrente: 100 token\n────────────────────\n= 2.300 token\n= Entra perfettamente!" }}
/>

### Strategie di Riassunto

Approcci diversi funzionano per casi d'uso diversi. Clicca ogni strategia per vedere come elabora la stessa conversazione:

<SummarizationDemo />

### Cosa Catturare nei Riassunti

Un buon riassunto di conversazione preserva ciò che conta:

<Checklist 
  title="Checklist Riassunto"
  items={[
    { text: "Decisioni chiave prese" },
    { text: "Fatti importanti menzionati" },
    { text: "Preferenze utente scoperte" },
    { text: "Compito o obiettivo corrente" },
    { text: "Eventuali domande in sospeso" },
    { text: "Tono e livello di formalità" }
  ]}
/>

### Prova: Crea un Riassunto

<TryIt 
  title="Riassuntore Conversazione"
  description="Esercitati a creare un riassunto che preserva il contesto da questa conversazione:"
  prompt={`Riassumi questa conversazione per la gestione del contesto. Il riassunto sostituirà la conversazione completa nella memoria dell'IA.

CONVERSAZIONE:
Utente: Ciao, sto imparando Python per l'analisi dati
Assistente: Benvenuto! Python è ottimo per l'analisi dati. Qual è il tuo livello di esperienza attuale?
Utente: Conosco Excel base. Principiante assoluto con la programmazione.
Assistente: Ottimo punto di partenza! Iniziamo con le variabili - sono come celle Excel che memorizzano dati.
Utente: Puoi spiegare le variabili?
Assistente: Le variabili sono contenitori per memorizzare dati. In Python: nome = "Alice" o eta = 25
Utente: E le liste? Ho bisogno di gestire valori multipli.
Assistente: Le liste sono come colonne Excel! Creane una così: prezzi = [10, 20, 30]. Accedi agli elementi con prezzi[0].
Utente: Posso fare calcoli sulle liste?
Assistente: Sì! Usa sum(prezzi), len(prezzi), o max(prezzi). Per analisi complesse, useremo pandas dopo.
Utente: Cos'è pandas?
Assistente: Pandas è una libreria per l'analisi dati - pensa "Excel sotto steroidi". Ha i DataFrame (come fogli di calcolo).

CREA UN RIASSUNTO che catturi:
1. Obiettivo e background dell'utente (1 frase)
2. Argomenti coperti finora (1 frase)  
3. Stile/preferenze di apprendimento dell'utente (1 frase)
4. Cosa coprire dopo (1 frase)`}
/>

### Quando Riassumere

<TryIt compact prompt={`Stai gestendo la finestra di contesto di una conversazione. Date queste condizioni, decidi quando attivare il riassunto:

FINESTRA DI CONTESTO: 8.000 token max
UTILIZZO CORRENTE:
- System prompt: 500 token
- Storico conversazione: 6.200 token  
- Buffer per risposta: 1.500 token

REGOLE:
- Riassumi quando lo storico supera il 70% dello spazio disponibile
- Mantieni gli ultimi 5 messaggi intatti
- Preserva tutte le preferenze e decisioni dell'utente

Dovresti riassumere ora? Se sì, quali messaggi dovrebbero essere riassunti vs mantenuti intatti?`} />

## MCP: Model Context Protocol

MCP (Model Context Protocol) è un modo standard per connettere l'IA a dati e strumenti esterni. Invece di costruire integrazioni personalizzate per ogni provider IA, MCP fornisce un'interfaccia universale.

### Perché MCP?

<InfoGrid columns={2} items={[
  { label: "Senza MCP", description: "Costruisci integrazioni separate per ChatGPT, Claude, Gemini... Mantieni molteplici codebase. Si rompono quando le API cambiano.", color: "red" },
  { label: "Con MCP", description: "Costruisci una volta, funziona ovunque. Protocollo standard. L'IA può scoprire e usare i tuoi strumenti automaticamente.", color: "green" },
]} />

### MCP Fornisce

- **Resources**: Dati che l'IA può leggere (file, record database, risposte API)
- **Tools**: Azioni che l'IA può compiere (cerca, crea, aggiorna, elimina)
- **Prompts**: Template di prompt pre-costruiti

<Callout type="info" title="prompts.chat Usa MCP">
Questa piattaforma ha un server MCP! Puoi connetterlo a Claude Desktop o altri client compatibili MCP per cercare e usare prompt direttamente dal tuo assistente IA.
</Callout>

## Costruire il Contesto: Il Quadro Completo

<ContextPlayground />

## Best Practice

<Checklist 
  title="Checklist Context Engineering"
  items={[
    { text: "Mantieni i system prompt concisi ma completi" },
    { text: "Includi solo contesto rilevante (non tutto)" },
    { text: "Riassumi le conversazioni lunghe" },
    { text: "Usa RAG per conoscenza specifica di dominio" },
    { text: "Dai all'IA strumenti per dati in tempo reale" },
    { text: "Monitora l'uso dei token per rimanere nei limiti" },
    { text: "Testa con casi limite (input molto lunghi, ecc.)" }
  ]}
/>

## Riepilogo

Il context engineering riguarda dare all'IA le informazioni giuste:

- **L'IA è stateless** - includi tutto ciò di cui ha bisogno ogni volta
- **RAG** recupera documenti rilevanti per arricchire i prompt
- **Embeddings** abilitano la ricerca semantica (significato, non solo parole chiave)
- **Function calling** permette all'IA di usare strumenti esterni
- **Riassunto** gestisce le conversazioni lunghe
- **MCP** standardizza come l'IA si connette a dati e strumenti

<Callout type="tip" title="Ricorda">
La qualità dell'output IA dipende dalla qualità del contesto che fornisci. Contesto migliore = risposte migliori.
</Callout>
