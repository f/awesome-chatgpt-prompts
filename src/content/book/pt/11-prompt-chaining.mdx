Encadeamento de prompts divide tarefas complexas em sequências de prompts mais simples, onde a saída de cada etapa alimenta a próxima. Esta técnica melhora dramaticamente a confiabilidade e permite workflows sofisticados que seriam impossíveis com um único prompt.

<Callout type="tip" title="Pense em Linhas de Montagem">
Assim como uma linha de montagem de fábrica divide a manufatura em estações especializadas, encadeamento de prompts divide tarefas de IA em etapas especializadas. Cada etapa faz uma coisa bem, e a saída combinada é muito melhor do que tentar fazer tudo de uma vez.
</Callout>

## Por Que Encadear Prompts?

Prompts únicos têm dificuldade com tarefas complexas porque tentam fazer demais de uma vez. A IA tem que simultaneamente entender, analisar, planejar e gerar, o que leva a erros e inconsistências.

<div className="my-6 grid md:grid-cols-2 gap-4">
  <div className="border rounded-lg bg-red-50/50 dark:bg-red-950/20 border-red-200 dark:border-red-900">
    <p className="text-sm font-semibold text-red-700 dark:text-red-400 px-4 pt-3 flex items-center gap-2 m-0!"><IconX className="h-4 w-4" /> Prompt Único Tem Dificuldade</p>
    <div className="text-sm p-4 pt-2 space-y-1">
      <p className="m-0!">Raciocínio multi-etapas se confunde</p>
      <p className="m-0!">Diferentes "modos" de pensamento colidem</p>
      <p className="m-0!">Saídas complexas carecem de consistência</p>
      <p className="m-0!">Sem oportunidade para controle de qualidade</p>
    </div>
  </div>
  <div className="border rounded-lg bg-green-50/50 dark:bg-green-950/20 border-green-200 dark:border-green-900">
    <p className="text-sm font-semibold text-green-700 dark:text-green-400 px-4 pt-3 flex items-center gap-2 m-0!"><IconCheck className="h-4 w-4" /> Encadeamento Resolve Isso</p>
    <div className="text-sm p-4 pt-2 space-y-1">
      <p className="m-0!">Cada etapa foca em uma tarefa</p>
      <p className="m-0!">Prompts especializados para cada modo</p>
      <p className="m-0!">Validar entre etapas</p>
      <p className="m-0!">Debugar e melhorar etapas individuais</p>
    </div>
  </div>
</div>

## Padrão Básico de Encadeamento

A cadeia mais simples passa saída de um prompt diretamente para o próximo. Cada etapa tem um propósito claro e focado.

<div className="my-6 flex items-center justify-center gap-3 p-6 bg-muted/30 rounded-lg overflow-x-auto">
  <div className="flex flex-col items-center">
    <div className="px-4 py-3 bg-blue-100 dark:bg-blue-900/50 border border-blue-200 dark:border-blue-800 rounded-lg text-center">
      <p className="text-sm font-medium text-blue-700 dark:text-blue-300 m-0!">Prompt 1</p>
      <p className="text-xs text-blue-600 dark:text-blue-400 m-0!">(Extrair)</p>
    </div>
    <p className="text-xs text-muted-foreground mt-1 m-0!">Entrada</p>
  </div>
  <div className="text-blue-400 dark:text-blue-500">→</div>
  <div className="flex flex-col items-center">
    <div className="px-4 py-3 bg-purple-100 dark:bg-purple-900/50 border border-purple-200 dark:border-purple-800 rounded-lg text-center">
      <p className="text-sm font-medium text-purple-700 dark:text-purple-300 m-0!">Prompt 2</p>
      <p className="text-xs text-purple-600 dark:text-purple-400 m-0!">(Analisar)</p>
    </div>
    <p className="text-xs text-muted-foreground mt-1 m-0!">Intermediário</p>
  </div>
  <div className="text-purple-400 dark:text-purple-500">→</div>
  <div className="flex flex-col items-center">
    <div className="px-4 py-3 bg-green-100 dark:bg-green-900/50 border border-green-200 dark:border-green-800 rounded-lg text-center">
      <p className="text-sm font-medium text-green-700 dark:text-green-300 m-0!">Prompt 3</p>
      <p className="text-xs text-green-600 dark:text-green-400 m-0!">(Gerar)</p>
    </div>
    <p className="text-xs text-muted-foreground mt-1 m-0!">Saída</p>
  </div>
</div>

<Callout type="info" title="O Padrão ETG">
O padrão de cadeia mais comum é **Extrair → Transformar → Gerar**. Primeiro extraia dados brutos, depois reformule para seu propósito, então gere a saída final. Este padrão funciona para quase qualquer tarefa de conteúdo.
</Callout>

## Tipos de Cadeia

Diferentes tarefas requerem diferentes arquiteturas de cadeia. Escolha o padrão que corresponde ao seu workflow.

<ChainFlowDemo />

### Cadeia Sequencial

O padrão mais direto: cada etapa depende da anterior. Pense nisso como uma corrida de revezamento onde cada corredor passa o bastão para o próximo.

<ChainExample 
  type="sequential"
  steps={[
    { step: "Etapa 1: Extrair", prompt: "Extraia todas as datas, nomes e números de: [texto]", output: '{ datas: ["2024-01-15", "2024-02-20"], nomes: ["João Silva", "Acme Corp"], numeros: [15000, 42] }' },
    { step: "Etapa 2: Analisar", prompt: "Dados estes dados extraídos: [saida_etapa1], identifique relacionamentos e padrões.", output: '{ padroes: ["Reuniões mensais agendadas"], relacionamentos: ["João Silva trabalha na Acme Corp"] }' },
    { step: "Etapa 3: Gerar", prompt: "Usando estes padrões: [saida_etapa2], escreva um relatório resumo destacando as descobertas mais significativas.", output: "Relatório Resumo: Análise do documento revela uma relação comercial entre João Silva e Acme Corp, com reuniões mensais agendadas..." }
  ]}
/>

### Cadeia Paralela

Quando você precisa de múltiplas perspectivas sobre a mesma entrada, execute prompts em paralelo e mescle resultados. Isso é mais rápido que cadeias sequenciais e fornece análise mais rica.

<ChainExample 
  type="parallel"
  steps={[
    { step: "Entrada", prompt: "Texto de avaliação de produto", output: '"Amo esses fones! A bateria dura muito e o display na caixinha é super conveniente. Perfeito pro meu trajeto diário."' },
    { step: "Ramo A: Sentimento", prompt: "Analise sentimento: [texto]", output: '{ sentimento: "positivo", score: 0.85 }' },
    { step: "Ramo B: Recursos", prompt: "Extraia recursos mencionados: [texto]", output: '{ recursos: ["bateria", "display"] }' },
    { step: "Ramo C: Persona", prompt: "Identifique persona do usuário: [texto]", output: '{ persona: "pendular" }' },
    { step: "Mesclar", prompt: "Combine análises em relatório unificado", output: "Relatório Unificado: Avaliação positiva de um pendular destacando bateria e display." }
  ]}
/>

### Cadeia Condicional

Encaminhe entradas por diferentes caminhos baseado em classificação. Isso é como uma árvore de decisão onde a IA primeiro categoriza a entrada, depois trata cada categoria diferentemente.

<ChainExample 
  type="conditional"
  steps={[
    { step: "Classificar Entrada", prompt: "Classifique esta mensagem de cliente como: reclamação, pergunta, feedback ou outro.\n\nMensagem: [texto]", output: '{ classificacao: "reclamação", confianca: 0.92 }' },
    { step: "Rota: Pergunta (pulada)", prompt: "Identifique qual informação é necessária", output: "Pulada - entrada classificada como reclamação" },
    { step: "Rota: Reclamação", prompt: "Identifique o problema e gravidade: [texto]", output: '{ problema: "atraso no frete", gravidade: "média" }' },
    { step: "Gerar Resposta", prompt: "Gere resposta empática com resolução: [análise]", output: "Prezado Cliente, Pedimos sinceras desculpas pelo atraso. Seu pedido foi priorizado..." }
  ]}
/>

### Cadeia Iterativa

Continue refinando saída até atender padrões de qualidade. A IA gera, avalia e melhora em loop até satisfeita ou máximo de iterações atingido.

<Callout type="warning" title="Defina Limites de Iteração">
Sempre defina um número máximo de iterações (tipicamente 3-5) para prevenir loops infinitos e controlar custos. A lei de retornos decrescentes se aplica: a maioria da melhoria acontece nas primeiras 2-3 iterações.
</Callout>

<ChainExample 
  type="iterative"
  steps={[
    { step: "Gerar Rascunho", prompt: "Escreva uma descrição de produto para: [fones sem fio]", output: "Estes fones sem fio oferecem boa qualidade de som e encaixe confortável para uso diário." },
    { step: "Avaliar (Nota: 5)", prompt: "Avalie esta descrição de 1-10 em: clareza, persuasividade, precisão.\n\nDescrição: [rascunho_atual]", output: '{ nota: 5, melhorias: ["Adicionar recursos específicos", "Incluir benefícios emocionais", "Mencionar duração da bateria", "Adicionar call-to-action"] }' },
    { step: "Melhorar Rascunho", prompt: "Melhore esta descrição baseado neste feedback:\n\nAtual: [rascunho_atual]\nFeedback: [melhorias]", output: "Experimente áudio cristalino com nossos fones sem fio premium. Com 30 horas de bateria, cancelamento ativo de ruído e design ergonômico que permanece confortável o dia todo. Perfeito para amantes de música e profissionais. Peça agora e transforme sua experiência auditiva." },
    { step: "Avaliar (Nota: 8)", prompt: "Avalie esta descrição de 1-10 em: clareza, persuasividade, precisão.\n\nDescrição: [rascunho_melhorado]", output: '{ nota: 8, melhorias: ["Menor: Poderia adicionar info de garantia"] }\n\n✓ Nota >= 8: SAIR DO LOOP' }
  ]}
/>

## Padrões Comuns de Cadeia

Estes padrões testados em batalha resolvem problemas comuns. Use-os como pontos de partida e adapte às suas necessidades.

### Extrair → Transformar → Gerar

O cavalo de batalha do processamento de conteúdo. Puxe dados, reformule-os, depois crie algo novo.

<div className="mb-4 p-3 rounded-lg bg-blue-50/50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800">
  <p className="text-xs font-semibold text-blue-700 dark:text-blue-300 mb-1 m-0!">Melhor Para</p>
  <p className="text-sm text-blue-600 dark:text-blue-400 m-0!">Sumarização de documentos, geração de relatórios, reaproveitamento de conteúdo, conversão dados-para-narrativa</p>
</div>

<ChainExample 
  type="sequential"
  steps={[
    { step: "Extrair", prompt: "Deste documento, extraia:\n- Tópico principal\n- Argumentos-chave (lista)\n- Evidências de suporte (lista)\n- Conclusões\nRetorne como JSON.", output: '{ "topico": "Impactos das mudanças climáticas", "argumentos": ["Temperaturas crescentes", "Elevação do nível do mar"], "evidencias": ["Dados da NASA", "Relatórios do IPCC"], "conclusoes": ["Ação urgente necessária"] }' },
    { step: "Transformar", prompt: "Reorganize esta informação para [executivos de negócios]:\n[dados_extraidos]\nFoque em: implicações econômicas\nRemova: jargão técnico", output: '{ "resumo": "Riscos climáticos para negócios", "pontos_chave": ["Disrupção da cadeia de suprimentos", "Custos de seguro crescendo"], "itens_acao": ["Avaliar vulnerabilidades", "Planejar adaptações"] }' },
    { step: "Gerar", prompt: "Usando esta informação reestruturada, escreva um [resumo executivo]:\n[dados_transformados]\nTom: profissional\nTamanho: 200 palavras", output: "Resumo Executivo: Mudanças climáticas apresentam riscos operacionais significativos ao nosso negócio. Preocupações principais incluem disrupções na cadeia de suprimentos por eventos climáticos extremos e prêmios de seguro crescentes. Recomendamos avaliação imediata de vulnerabilidades das instalações e desenvolvimento de estratégias de adaptação..." }
  ]}
/>

### Analisar → Planejar → Executar

Perfeito para refatoração de código, planejamento de projeto ou qualquer tarefa onde você precisa entender antes de agir.

<div className="mb-4 p-3 rounded-lg bg-purple-50/50 dark:bg-purple-950/20 border border-purple-200 dark:border-purple-800">
  <p className="text-xs font-semibold text-purple-700 dark:text-purple-300 mb-1 m-0!">Melhor Para</p>
  <p className="text-sm text-purple-600 dark:text-purple-400 m-0!">Refatoração de código, planejamento de projeto, troubleshooting, tomada de decisão estratégica, resolução de problemas complexos</p>
</div>

<ChainExample 
  type="sequential"
  steps={[
    { step: "Analisar", prompt: "Analise esta estrutura de codebase e identifique:\n- Padrão de arquitetura\n- Componentes principais\n- Dependências\n- Problemas potenciais\n[código]", output: '{ "padrao": "MVC", "componentes": ["UserController", "AuthService", "Database"], "dependencias": ["express", "mongoose"], "problemas": ["Sem validação de entrada", "Secrets hardcoded"] }' },
    { step: "Planejar", prompt: "Baseado nesta análise, crie um plano de refatoração:\n[saida_analise]\nObjetivo: melhorar segurança\nRestrições: sem breaking changes", output: '{ "passos": ["1. Adicionar middleware de validação", "2. Mover secrets para env vars", "3. Adicionar rate limiting"], "prioridade": "alta", "tempo_estimado": "4 horas" }' },
    { step: "Executar", prompt: "Implemente o passo 1 deste plano:\n[saida_plano]\nMostre o código refatorado com explicações.", output: "// Middleware de validação adicionado\nconst validateInput = (req, res, next) => {\n  const { email, password } = req.body;\n  if (!email || !isValidEmail(email)) {\n    return res.status(400).json({ error: 'Email inválido' });\n  }\n  next();\n};" }
  ]}
/>

### Gerar → Criticar → Refinar

O loop de auto-melhoria. Gere conteúdo, faça a IA avaliá-lo criticamente, depois melhore baseado nesse feedback. Isso imita como escritores profissionais e editores trabalham juntos.

<div className="mb-4 p-3 rounded-lg bg-green-50/50 dark:bg-green-950/20 border border-green-200 dark:border-green-800">
  <p className="text-xs font-semibold text-green-700 dark:text-green-300 mb-1 m-0!">Melhor Para</p>
  <p className="text-sm text-green-600 dark:text-green-400 m-0!">Copy de marketing, escrita criativa, rascunhos de email, apresentações, qualquer conteúdo que se beneficia de revisão</p>
</div>

<ChainExample 
  type="iterative"
  steps={[
    { step: "Gerar", prompt: "Escreva um email de marketing para [app de fitness] visando [profissionais ocupados].", output: "Assunto: Fique Em Forma Rápido!\n\nOi! Nosso app ajuda você a se exercitar. Baixe hoje e comece sua jornada fitness. Obrigado!" },
    { step: "Criticar", prompt: "Como especialista em marketing, critique este email:\n[email_gerado]\nAvalie: linha de assunto, gancho, proposta de valor, CTA, tom\nPontue cada de 1-10.", output: '{ "linha_assunto": 4, "gancho": 3, "proposta_valor": 2, "cta": 5, "tom": 4, "feedback": "Muito genérico, sem benefícios específicos, urgência fraca" }' },
    { step: "Refinar", prompt: "Reescreva o email abordando este feedback:\nOriginal: [email_gerado]\nCrítica: [saida_critica]\nFoque nos elementos com menor pontuação.", output: "Assunto: Treinos de 15 Min pro Seu Horário de Almoço\n\nAgenda apertada? A gente entende. Nosso app entrega treinos baseados em ciência feitos para profissionais que não têm tempo a perder. Junte-se a 50.000+ executivos que transformaram sua saúde em apenas 15 minutos por dia. Comece seu trial grátis agora—seu eu do futuro vai agradecer." },
    { step: "Nota Final", prompt: "Reavalie o email refinado.", output: '{ "linha_assunto": 8, "gancho": 8, "proposta_valor": 9, "cta": 8, "tom": 9, "melhoria": "+23 pontos total" }' }
  ]}
/>

## Implementando Cadeias

Você pode implementar cadeias manualmente para experimentação, ou programaticamente para sistemas de produção. Comece simples e adicione complexidade conforme necessário.

### Encadeamento Manual

A abordagem de copiar-colar é perfeita para prototipagem e experimentação. Execute cada prompt manualmente, examine a saída e cole-a no próximo prompt.

<CodeEditor 
  language="python"
  filename="manual_chain.py"
  code={`# Pseudocódigo para encadeamento manual
saida_etapa1 = chamar_ia("Extrair entidades de: " + texto_entrada)
saida_etapa2 = chamar_ia("Analisar relacionamentos: " + saida_etapa1)
saida_final = chamar_ia("Gerar relatório: " + saida_etapa2)`}
/>

### Encadeamento Programático

Para sistemas de produção, automatize a cadeia com código. Isso permite tratamento de erros, logging e integração com sua aplicação.

<CodeEditor 
  language="python"
  filename="chain.py"
  code={`def cadeia_analise(documento):
    # Etapa 1: Resumir
    resumo = chamar_ia(f"""
        Resuma os pontos-chave deste documento em 5 bullets:
        {documento}
    """)
    
    # Etapa 2: Extrair entidades
    entidades = chamar_ia(f"""
        Extraia entidades nomeadas (pessoas, organizações, locais) 
        deste resumo. Retorne como JSON.
        {resumo}
    """)
    
    # Etapa 3: Gerar insights
    insights = chamar_ia(f"""
        Baseado neste resumo e entidades, gere 3 insights 
        acionáveis para um analista de negócios.
        Resumo: {resumo}
        Entidades: {entidades}
    """)
    
    return {
        "resumo": resumo,
        "entidades": json.loads(entidades),
        "insights": insights
    }`}
/>

### Usando Templates de Cadeia

Defina cadeias como arquivos de configuração para reusabilidade e fácil modificação. Isso separa lógica de prompt do código da aplicação.

<CodeEditor 
  language="yaml"
  filename="chain_template.yaml"
  code={`name: "Cadeia de Análise de Documento"
steps:
  - name: "extrair"
    prompt: |
      Extraia informação-chave deste documento:
      {input}
      Retorne JSON com: topicos, entidades, datas, numeros
    
  - name: "analisar"
    prompt: |
      Analise estes dados extraídos para padrões:
      {extrair.output}
      Identifique: tendências, anomalias, relacionamentos
    
  - name: "relatorio"
    prompt: |
      Gere um resumo executivo baseado em:
      Dados: {extrair.output}
      Análise: {analisar.output}
      Formato: 3 parágrafos, tom de negócios`}
/>

## Tratamento de Erros em Cadeias

Cadeias podem falhar em qualquer etapa. Incorpore validação, retentativas e fallbacks para tornar suas cadeias robustas.

<ChainErrorDemo />

<Callout type="warning" title="Lixo Entra, Lixo Sai">
Se uma etapa produz saída ruim, toda etapa seguinte será afetada. Sempre valide resultados intermediários críticos antes de passá-los adiante.
</Callout>

### Validação Entre Etapas

Adicione uma etapa de validação após qualquer etapa que produz dados estruturados. Isso captura erros cedo antes que cascateiem.

<ValidationDemo />

### Cadeias de Fallback

Quando sua abordagem principal falha, tenha um backup mais simples pronto. Troque capacidade por confiabilidade.

<FallbackDemo />

## Otimização de Cadeia

Uma vez que sua cadeia funcione, otimize para velocidade, custo e confiabilidade. Estes frequentemente têm trade-offs entre si.

<div className="my-6 grid md:grid-cols-3 gap-4">
  <div className="border rounded-lg bg-blue-50/50 dark:bg-blue-950/20 border-blue-200 dark:border-blue-900 p-4">
    <p className="text-sm font-semibold text-blue-700 dark:text-blue-400 mb-2 m-0!">Reduzindo Latência</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">Paralelizar etapas independentes</p>
      <p className="m-0!">Cache de resultados intermediários</p>
      <p className="m-0!">Usar modelos menores para etapas simples</p>
      <p className="m-0!">Agrupar operações similares</p>
    </div>
  </div>
  <div className="border rounded-lg bg-green-50/50 dark:bg-green-950/20 border-green-200 dark:border-green-900 p-4">
    <p className="text-sm font-semibold text-green-700 dark:text-green-400 mb-2 m-0!">Reduzindo Custo</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">Usar modelos mais baratos para classificação</p>
      <p className="m-0!">Limitar iterações em loops</p>
      <p className="m-0!">Short-circuit quando possível</p>
      <p className="m-0!">Cache de queries repetidas</p>
    </div>
  </div>
  <div className="border rounded-lg bg-purple-50/50 dark:bg-purple-950/20 border-purple-200 dark:border-purple-900 p-4">
    <p className="text-sm font-semibold text-purple-700 dark:text-purple-400 mb-2 m-0!">Melhorando Confiabilidade</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">Adicionar validação entre etapas</p>
      <p className="m-0!">Incluir lógica de retry</p>
      <p className="m-0!">Logar resultados intermediários</p>
      <p className="m-0!">Implementar caminhos de fallback</p>
    </div>
  </div>
</div>

## Exemplo de Cadeia do Mundo Real

Vamos percorrer uma cadeia de produção completa. Este pipeline de conteúdo transforma uma ideia bruta em um pacote de artigo polido.

### Cadeia de Pipeline de Conteúdo

<ContentPipelineDemo />

## Resumo

Encadeamento de prompts transforma o que IA pode realizar ao dividir tarefas impossíveis em etapas alcançáveis.

<div className="my-6 grid md:grid-cols-2 gap-4">
  <div className="border rounded-lg bg-amber-50/50 dark:bg-amber-950/20 border-amber-200 dark:border-amber-900 p-4">
    <p className="text-sm font-semibold text-amber-700 dark:text-amber-400 mb-2 m-0!">Encadeamento Permite</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">Workflows complexos de múltiplas etapas</p>
      <p className="m-0!">Maior qualidade através de especialização</p>
      <p className="m-0!">Melhor tratamento de erros e validação</p>
      <p className="m-0!">Componentes de prompt modulares e reutilizáveis</p>
    </div>
  </div>
  <div className="border rounded-lg bg-cyan-50/50 dark:bg-cyan-950/20 border-cyan-200 dark:border-cyan-900 p-4">
    <p className="text-sm font-semibold text-cyan-700 dark:text-cyan-400 mb-2 m-0!">Princípios-Chave</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">Dividir tarefas complexas em etapas simples</p>
      <p className="m-0!">Projetar interfaces claras entre etapas</p>
      <p className="m-0!">Validar saídas intermediárias</p>
      <p className="m-0!">Incorporar tratamento de erros e fallbacks</p>
      <p className="m-0!">Otimizar para suas restrições</p>
    </div>
  </div>
</div>

<Callout type="tip" title="Comece Simples">
Comece com uma cadeia sequencial de 2-3 etapas. Faça funcionar confiavelmente antes de adicionar complexidade. A maioria das tarefas não precisa de arquiteturas de cadeia elaboradas.
</Callout>

<Quiz 
  question="Qual é a principal vantagem do encadeamento de prompts sobre um único prompt complexo?"
  options={[
    "Usa menos tokens no total",
    "É mais rápido de executar",
    "Cada etapa pode se especializar, melhorando qualidade e permitindo tratamento de erros",
    "Requer menos planejamento"
  ]}
  correctIndex={2}
  explanation="Encadeamento de prompts divide tarefas complexas em etapas especializadas. Cada etapa pode focar em uma coisa bem, resultados intermediários podem ser validados, erros podem ser capturados e retentados, e a qualidade geral melhora através da especialização."
/>

No próximo capítulo, exploraremos prompting multimodal: trabalhando com imagens, áudio e outros conteúdos não-texto.
