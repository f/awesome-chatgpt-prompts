一貫性があり、適切にフォーマットされた出力を得ることは、本番アプリケーションや効率的なワークフローにとって不可欠です。この章では、AIモデルがレスポンスをどのようにフォーマットするかを正確に制御するテクニックを解説します。

<Callout type="info" title="散文からデータへ">
構造化出力は、AIのレスポンスを自由形式のテキストから、アクション可能でパース可能なデータに変換します。
</Callout>

## 構造化が重要な理由

<StructuredOutputDemo />

## 基本的なフォーマット技法

### リスト

リストは、段階的な手順、ランク付けされた項目、または関連するポイントの集まりに最適です。スキャンしやすく、パースも簡単です。順序が重要な場合（手順、ランキング）は**番号付きリスト**を使用し、順序のないコレクションには**箇条書き**を使用します。

<TryIt 
  compact
  title="リストのフォーマット"
  prompt={`より良い睡眠のための5つのヒントを教えてください。

フォーマット：各項目に簡単な説明を付けた番号付きリスト。
各ヒントは太字にし、その後にダッシュと説明を付けてください。`}
/>

<Callout type="tip" title="リストのベストプラクティス">
欲しい項目の正確な数、説明を含めるかどうか、項目を太字にするか特定の構造にするかを指定してください。
</Callout>

### テーブル

テーブルは、複数の項目を同じ観点で比較するのに優れています。機能比較、データの要約、一貫した属性を持つあらゆる情報に最適です。列のヘッダーは常に明示的に定義してください。

<TryIt 
  compact
  title="テーブルのフォーマット"
  prompt={`Pythonの主要なWebフレームワーク4つを比較してください。

以下の列を持つMarkdownテーブルとしてフォーマットしてください：
| フレームワーク | 最適な用途 | 学習曲線 | パフォーマンス |`}
/>

<Callout type="tip" title="テーブルのベストプラクティス">
列名、期待するデータ型（テキスト、数値、評価）、必要な行数を指定してください。複雑な比較の場合、読みやすさのために4〜6列に制限することをお勧めします。
</Callout>

### 見出しとセクション

見出しは明確な文書構造を作成し、長いレスポンスをスキャンしやすく整理します。レポート、分析、または複数のパートからなるレスポンスに使用してください。階層的な見出し（##、###）はセクション間の関係を示します。

```
このビジネス提案を分析してください。

以下のセクションでレスポンスを構成してください：
## エグゼクティブサマリー
## 強み
## 弱み
## 推奨事項
## リスク評価
```

<Callout type="tip" title="セクションのベストプラクティス">
セクションを希望する順序でリストしてください。一貫性のために、各セクションに何を含めるべきかを指定してください（例：「エグゼクティブサマリー：2〜3文のみ」）。
</Callout>

### 大文字指示による強調

大文字の単語は、重要な制約や要件を強調するモデルへの強いシグナルとして機能します。最大の効果を得るために控えめに使用してください—使いすぎると効果が薄れます。

**一般的な大文字指示：**

<InfoGrid items={[
  { label: "NEVER", description: "絶対禁止：「NEVER include personal opinions」（個人的な意見を含めないでください）", color: "red" },
  { label: "ALWAYS", description: "必須要件：「ALWAYS cite sources」（常に出典を引用してください）", color: "green" },
  { label: "IMPORTANT", description: "重要な指示：「IMPORTANT: Keep responses under 100 words」（重要：回答は100語以内に）", color: "amber" },
  { label: "DO NOT", description: "強い禁止：「DO NOT make up statistics」（統計を捏造しないでください）", color: "red" },
  { label: "MUST", description: "必須アクション：「Output MUST be valid JSON」（出力は有効なJSONでなければなりません）", color: "blue" },
  { label: "ONLY", description: "制限：「Return ONLY the code, no explanations」（コードのみを返し、説明は不要）", color: "purple" },
]} />

```
この記事を要約してください。

IMPORTANT: 要約は100語以内にしてください。
NEVER 元の記事にない情報を追加しないでください。
ALWAYS 元のトーンと視点を維持してください。
DO NOT あなた自身の意見や分析を含めないでください。
```

<Callout type="warning" title="控えめに使用する">
すべてが大文字であったり重要としてマークされていたりすると、何も目立たなくなります。これらの指示は本当に重要な制約のために取っておいてください。
</Callout>

## JSON出力

JSON（JavaScript Object Notation）は、構造化されたAI出力のための最も人気のあるフォーマットです。機械可読で、プログラミング言語で広くサポートされており、API、データベース、自動化ワークフローに最適です。信頼性の高いJSONの鍵は、明確なスキーマを提供することです。

### 基本的なJSONリクエスト

求める正確な構造を示すテンプレートから始めます。フィールド名、データ型、例の値を含めてください。これはモデルが従う契約として機能します。

<TryIt 
  title="JSONの抽出"
  description="非構造化テキストから構造化データを抽出します。"
  prompt={`このテキストから情報を抽出し、JSONとして返してください：

{
    "company_name": "string",
    "founding_year": number,
    "headquarters": "string",
    "employees": number,
    "industry": "string"
}

テキスト：「Apple Inc.は1976年に設立され、カリフォルニア州クパチーノに本社を置いています。このテクノロジー大手は、世界中で約164,000人の従業員を雇用しています。」`}
/>

### 複雑なJSON構造

ネストされたデータには、オブジェクト内のオブジェクト、オブジェクトの配列、混合型を持つ階層的なJSONを使用します。各レベルを明確に定義し、TypeScriptスタイルの注釈（`"positive" | "negative"`）を使用して値を制約します。

```
この製品レビューを分析し、JSONを返してください：

{
  "review_id": "string (generate unique)",
  "sentiment": {
    "overall": "positive" | "negative" | "mixed" | "neutral",
    "score": 0.0-1.0
  },
  "aspects": [
    {
      "aspect": "string (e.g., 'price', 'quality')",
      "sentiment": "positive" | "negative" | "neutral",
      "mentions": ["exact quotes from review"]
    }
  ],
  "purchase_intent": {
    "would_recommend": boolean,
    "confidence": 0.0-1.0
  },
  "key_phrases": ["string array of notable phrases"]
}

有効なJSONのみを返してください。追加のテキストは不要です。

レビュー：「[review text]」
```

### 有効なJSONを確保する

モデルは、JSONの周りに説明テキストやMarkdownフォーマットを追加することがあります。出力フォーマットについての明示的な指示でこれを防ぎます。生のJSONまたはコードブロック内のJSONをリクエストできます—パースのニーズに基づいて選択してください。

明示的な指示を追加します：

```
IMPORTANT:
- JSONオブジェクトのみを返し、Markdownコードブロックは不要です
- すべての文字列が適切にエスケープされていることを確認してください
- 欠損値にはundefinedではなくnullを使用してください
- 出力がパース可能なJSONであることを検証してください
```

または、モデルに出力をラップするよう依頼してコードブロックをリクエストします：

````
結果をJSONコードブロックとして返してください：
```json
{ ... }
```
````

## YAML出力

YAMLはJSONよりも人間が読みやすく、ブラケットの代わりにインデントを使用します。設定ファイル（Docker、Kubernetes、GitHub Actions）の標準であり、出力が人間によって読まれる場合やDevOpsコンテキストで使用される場合に適しています。YAMLはインデントに敏感なので、フォーマット要件について具体的に指定してください。

<TryIt 
  compact
  title="YAMLの生成"
  prompt={`Node.jsプロジェクト用のGitHub Actionsワークフローを生成してください。

有効なYAMLとして返してください：
- 含める内容：install、lint、test、buildステージ
- Node.js 18を使用
- npm依存関係をキャッシュ
- mainへのプッシュとプルリクエストで実行`}
/>

## XML出力

XMLは、多くのエンタープライズシステム、SOAP API、レガシー統合で依然として必要です。JSONよりも冗長ですが、属性、名前空間、複雑なデータ用のCDATAセクションなどの機能を提供します。要素名、ネスト構造、属性と子要素のどちらを使用するかを指定してください。

```
このデータをXMLフォーマットに変換してください：

要件：
- ルート要素：<catalog>
- 各アイテムを<book>要素に
- 適切な場所で属性を含める
- 説明テキストにはCDATAを使用

データ：[book data]
```

## カスタムフォーマット

標準フォーマットがニーズに合わないこともあります。明確なテンプレートを提供することで、任意のカスタムフォーマットを定義できます。カスタムフォーマットは、人間が読むレポート、ログ、またはドメイン固有の出力に適しています。

### 構造化分析フォーマット

区切り文字（===、---、[SECTION]）を使用して、セクション間に明確な境界を持つスキャン可能なドキュメントを作成します。このフォーマットは、コードレビュー、監査、分析に最適です。

```
このコードを正確に以下のフォーマットで分析してください：

=== CODE ANALYSIS ===

[SUMMARY]
1段落の概要

[ISSUES]
• CRITICAL: [issue] — [file:line]
• WARNING: [issue] — [file:line]  
• INFO: [issue] — [file:line]

[METRICS]
Complexity: [Low/Medium/High]
Maintainability: [score]/10
Test Coverage: [estimated %]

[RECOMMENDATIONS]
1. [Priority 1 recommendation]
2. [Priority 2 recommendation]

=== END ANALYSIS ===
```

### 空欄補充フォーマット

空欄（___）のあるテンプレートは、正確なフォーマットを維持しながら特定のフィールドを埋めるようモデルを導きます。このアプローチは、一貫性が重要なフォーム、ブリーフ、標準化されたドキュメントに優れています。

```
与えられた製品についてこのテンプレートを完成させてください：

PRODUCT BRIEF
─────────────
Name: _______________
Tagline: _______________
Target User: _______________
Problem Solved: _______________
Key Features:
  1. _______________
  2. _______________
  3. _______________
Differentiator: _______________

製品：[product description]
```

## 型付きレスポンス

型付きレスポンスは、モデルが認識してラベル付けすべきカテゴリまたはエンティティタイプを定義します。このテクニックは、固有表現認識（NER）、分類タスク、および情報を一貫してカテゴリ分けする必要があるあらゆる抽出に不可欠です。例を含めてタイプを明確に定義してください。

<TryIt 
  compact
  title="エンティティ抽出"
  prompt={`このテキストからエンティティを抽出してください。

エンティティタイプ：
- PERSON：人物のフルネーム
- ORG：組織/会社名
- LOCATION：都市、国、住所
- DATE：ISOフォーマットの日付（YYYY-MM-DD）
- MONEY：通貨付きの金額

各エンティティを以下のフォーマットで：[TYPE]: [value]

テキスト：「Tim CookはAppleが2024年12月までにオースティンの新施設に10億ドルを投資すると発表しました。」`}
/>

## 複数パートの構造化レスポンス

複数の側面をカバーする包括的な出力が必要な場合、明確な境界を持つ異なるパートを定義します。各パートに何を入れるか—フォーマット、長さ、コンテンツタイプを正確に指定します。これにより、モデルがセクションを混ぜたり、パートを省略したりすることを防ぎます。

```
このトピックをリサーチし、以下を提供してください：

### PART 1: EXECUTIVE SUMMARY
[2〜3文の概要]

### PART 2: KEY FINDINGS
[正確に5つの箇条書き]

### PART 3: DATA TABLE
| Metric | Value | Source |
|--------|-------|--------|
[最低5行を含める]

### PART 4: RECOMMENDATIONS
[3つの実行可能な推奨事項の番号付きリスト]

### PART 5: FURTHER READING
[簡単な説明付きの3つの推奨リソース]
```

## 条件付きフォーマット

条件付きフォーマットでは、入力の特性に基づいて異なる出力フォーマットを定義できます。これは、レスポンスフォーマットがモデルが検出した内容に基づいて変わるべき分類、トリアージ、ルーティングシステムに強力です。各ケースに対して明示的な出力テンプレートを持つ明確なif/thenロジックを使用してください。

<TryIt 
  compact
  title="チケット分類"
  prompt={`このサポートチケットを分類してください。

URGENT（システムダウン、セキュリティ問題、データ損失）の場合：
  返す：🔴 URGENT | [Category] | [Suggested Action]

HIGH（複数のユーザーに影響、収益への影響）の場合：
  返す：🟠 HIGH | [Category] | [Suggested Action]

MEDIUM（単一ユーザーに影響、回避策あり）の場合：
  返す：🟡 MEDIUM | [Category] | [Suggested Action]

LOW（質問、機能リクエスト）の場合：
  返す：🟢 LOW | [Category] | [Suggested Action]

チケット：「アカウントにログインできません。パスワードを2回リセットしようとしましたが、まだエラーが出ています。これにより、チーム全体がダッシュボードにアクセスできなくなっています。」`}
/>

## JSONにおける配列とリスト

複数の項目を配列に抽出するには、慎重なスキーマ定義が必要です。配列構造、各項目に何を含めるべきか、エッジケース（空の配列、単一項目）の処理方法を指定します。カウントフィールドを含めると、完全性の検証に役立ちます。

```
この会議の議事録からすべてのアクションアイテムを抽出してください。

JSON配列として返してください：
{
  "action_items": [
    {
      "task": "string describing the task",
      "assignee": "person name or 'Unassigned'",
      "deadline": "date if mentioned, else null",
      "priority": "high" | "medium" | "low",
      "context": "relevant quote from transcript"
    }
  ],
  "total_count": number
}

議事録：「[meeting transcript]」
```

## バリデーション指示

自己バリデーションは、モデルに応答する前に自身の出力をチェックするよう促します。これにより、欠落セクション、プレースホルダーテキスト、制約違反などの一般的な問題を検出できます。モデルは問題を修正するために内部で反復し、追加のAPI呼び出しなしに出力品質を向上させます。

```
レポートを生成し、その後：

VALIDATION CHECKLIST:
□ 必要なセクションがすべて存在する
□ プレースホルダーテキストが残っていない
□ すべての統計に出典が含まれている
□ 語数が500〜700語以内
□ 結論が導入部に結びついている

チェックに失敗した場合、応答前に修正してください。
```

## オプションフィールドの処理

実世界のデータには、欠損値がよくあります。オプションフィールドの処理方法についてモデルに明示的に指示してください—`null`を使用することは空文字列よりもクリーンで、プログラム的に処理しやすいです。また、欠落データの「幻覚」を防ぐために、モデルが情報を捏造してはならないことを強調してください。

```
連絡先情報を抽出してください。欠落フィールドにはnullを使用してください。

{
  "name": "string (required)",
  "email": "string or null",
  "phone": "string or null", 
  "company": "string or null",
  "role": "string or null",
  "linkedin": "URL string or null"
}

IMPORTANT: 
- ソースにない情報を捏造しないでください
- 欠落データには空文字列ではなくnullを使用してください
- 可能な場合、電話番号はE.164フォーマットで
```

## まとめ

<Callout type="tip" title="主要テクニック">
フォーマットを明示的に指定し、例を使用し、タイプを指定し、エッジケースをnull値で処理し、モデルに自身の出力を検証するよう依頼してください。
</Callout>

<Quiz 
  question="構造化出力の非構造化テキストに対する主な利点は何ですか？"
  options={[
    "トークンの使用量が少ない",
    "AIが生成しやすい",
    "プログラムでパースおよび検証できる",
    "常に正しい情報を生成する"
  ]}
  correctIndex={2}
  explanation="JSONなどの構造化出力は、コードでパースでき、クエリ間で比較でき、ワークフローに統合でき、完全性を検証できます—これらは自由形式のテキストでは困難または不可能なことです。"
/>

構造化出力は、信頼性の高いAI搭載アプリケーションを構築するために不可欠です。次の章では、複雑な推論タスクのためのチェーン・オブ・ソート・プロンプティングを探求します。
