一个好的提示词能完成任务。一个优化过的提示词能高效地完成任务——更快、更便宜、更稳定。本章将教你如何从多个维度系统性地改进提示词。

<Callout type="tip" title="试试提示词增强器">
想要自动优化你的提示词？使用我们的[提示词增强器](/developers#enhancer)工具。它会分析你的提示词，应用优化技术，并展示类似的社区提示词供你参考。
</Callout>

## 优化的权衡

每项优化都涉及权衡。理解这些权衡有助于你做出有意识的选择：

<InfoGrid items={[
  { label: "质量 vs. 成本", description: "更高的质量通常需要更多 token 或更好的模型", example: "添加示例可以提高准确性，但会增加 token 数量", exampleType: "text", color: "blue" },
  { label: "速度 vs. 质量", description: "更快的模型可能会牺牲一些能力", example: "GPT-4 比 GPT-4o-mini 更智能但更慢", exampleType: "text", color: "purple" },
  { label: "一致性 vs. 创造性", description: "较低的 temperature = 更可预测但创造性更低", example: "事实性内容用 0.2，头脑风暴用 0.8", exampleType: "text", color: "green" },
  { label: "简单性 vs. 稳健性", description: "边缘情况处理会增加复杂性", example: "简单的提示词在异常输入时会失败", exampleType: "text", color: "amber" }
]} />

## 衡量重要指标

在优化之前，先定义成功。对于你的用例来说，"更好"意味着什么？

<InfoGrid items={[
  { label: "准确性", description: "输出正确的频率有多高？", example: "90% 的代码建议可以无错误编译", exampleType: "text", color: "blue" },
  { label: "相关性", description: "是否回答了实际被问到的问题？", example: "回复直接回答问题 vs. 跑题", exampleType: "text", color: "blue" },
  { label: "完整性", description: "是否涵盖了所有要求？", example: "输出中包含所有 5 个要求的部分", exampleType: "text", color: "blue" },
  { label: "延迟", description: "响应到达需要多长时间？", example: "聊天应用 p50 < 2秒，p95 < 5秒", exampleType: "text", color: "purple" },
  { label: "Token 效率", description: "相同结果需要多少 token？", example: "500 tokens vs. 1500 tokens 达到相同输出", exampleType: "text", color: "purple" },
  { label: "一致性", description: "相似输入的输出有多相似？", example: "相同问题得到结构相似的答案", exampleType: "text", color: "green" }
]} />

<Callout type="info" title="p50 和 p95 是什么意思？">
百分位指标显示响应时间分布。**p50**（中位数）意味着 50% 的请求比这个值更快。**p95** 意味着 95% 更快——它能捕捉到慢速异常值。如果你的 p50 是 1 秒但 p95 是 10 秒，大多数用户体验良好，但有 5% 的用户会感到延迟困扰。
</Callout>

<TryIt 
  title="定义你的成功指标"
  description="在做出更改之前，使用此模板来明确你要优化的目标。"
  prompt={`帮我为提示词优化定义成功指标。

**我的用例**：\${useCase}
**当前痛点**：\${painPoints}

针对这个用例，帮我定义：

1. **主要指标**：哪个单一指标最重要？
2. **次要指标**：还应该跟踪什么？
3. **可接受的权衡**：为了主要指标可以牺牲什么？
4. **红线**：什么样的质量水平是不可接受的？
5. **如何衡量**：评估每个指标的实用方法`}
/>

## Token 优化

Token 花费金钱并增加延迟。以下是如何用更少的 token 表达相同的内容。

### 压缩原则

<Compare 
  before={{ label: "冗长版（67 tokens）", content: "I would like you to please help me with the following task. I need you to take the text that I'm going to provide below and create a summary of it. The summary should capture the main points and be concise. Please make sure to include all the important information. Here is the text:\n\n[text]" }}
  after={{ label: "简洁版（12 tokens）", content: "Summarize this text, capturing main points concisely:\n\n[text]" }}
/>

**相同结果，减少 82% 的 token。**

### Token 节省技巧

<InfoGrid items={[
  { label: "删除客套话", description: "\"Please\" 和 \"Thank you\" 增加 token 但不会改善输出", example: "\"Please summarize\" → \"Summarize\"", color: "green" },
  { label: "消除冗余", description: "不要重复自己或陈述显而易见的事情", example: "\"Write a summary that summarizes\" → \"Summarize\"", color: "green" },
  { label: "使用缩写", description: "在意思明确的地方使用缩写", example: "\"for example\" → \"e.g.\"", color: "green" },
  { label: "通过位置引用", description: "指向内容而不是重复它", example: "\"the text above\" 而不是重新引用", color: "green" }
]} />

<TryIt 
  title="提示词压缩器"
  description="粘贴一个冗长的提示词，获取 token 优化版本。"
  prompt={`压缩这个提示词，同时保留其含义和有效性：

原始提示词：
"\${verbosePrompt}"

说明：
1. 删除不必要的客套话和填充词
2. 消除冗余
3. 使用简洁的措辞
4. 保留所有关键指令和约束
5. 保持清晰——不要为了简短而牺牲理解

提供：
- **压缩版本**：优化后的提示词
- **Token 减少量**：估计节省的百分比
- **删除了什么**：简要说明删除了什么以及为什么可以安全删除`}
/>

## 质量优化

有时你需要更好的输出，而不是更便宜的输出。以下是如何提高质量。

### 准确性提升技巧

<InfoGrid items={[
  { label: "添加验证", description: "让模型检查自己的工作", example: "\"...then verify your answer is correct\"", color: "blue" },
  { label: "请求置信度", description: "让不确定性明确化", example: "\"Rate your confidence 1-10 and explain any uncertainty\"", color: "blue" },
  { label: "多种方法", description: "获取不同的视角，然后选择", example: "\"Provide 3 approaches and recommend the best one\"", color: "blue" },
  { label: "明确推理", description: "强制逐步思考", example: "\"Think step by step and show your reasoning\"", color: "blue" }
]} />

### 一致性提升技巧

<InfoGrid items={[
  { label: "详细格式规范", description: "准确展示输出应该是什么样子", example: "包含模板或 schema", exampleType: "text", color: "purple" },
  { label: "少样本示例", description: "提供 2-3 个理想输出的示例", example: "\"Here's what good looks like: [examples]\"", color: "purple" },
  { label: "降低 Temperature", description: "减少随机性以获得更可预测的输出", example: "Temperature 0.3-0.5 以获得一致的结果", exampleType: "text", color: "purple" },
  { label: "输出验证", description: "为关键字段添加验证步骤", example: "\"Verify all required fields are present\"", color: "purple" }
]} />

<TryIt 
  title="质量增强器"
  description="为你的提示词添加质量提升元素。"
  prompt={`增强这个提示词以获得更高质量的输出：

原始提示词：
"\${originalPrompt}"

**我看到的质量问题**：\${qualityIssue}

添加适当的质量提升器：
1. 如果问题是准确性 → 添加验证步骤
2. 如果问题是一致性 → 添加格式规范或示例
3. 如果问题是相关性 → 添加上下文和约束
4. 如果问题是完整性 → 添加明确的要求

提供增强后的提示词，并解释每个添加项。`}
/>

## 延迟优化

当速度很重要时，每毫秒都很关键。

### 按速度需求选择模型

<InfoGrid items={[
  { label: "实时（< 500ms）", description: "使用最小有效模型 + 积极缓存", example: "GPT-4o-mini、Claude Haiku、缓存响应", exampleType: "text", color: "red" },
  { label: "交互式（< 2s）", description: "快速模型，启用流式输出", example: "GPT-4o-mini 配合流式输出", exampleType: "text", color: "amber" },
  { label: "可容忍（< 10s）", description: "中等模型，平衡质量/速度", example: "GPT-4o、Claude Sonnet", exampleType: "text", color: "green" },
  { label: "异步/批量", description: "使用最佳模型，后台处理", example: "GPT-4、Claude Opus 用于离线处理", exampleType: "text", color: "blue" }
]} />

### 速度优化技巧

<InfoGrid items={[
  { label: "更短的提示词", description: "更少的输入 token = 更快的处理", example: "压缩提示词，删除不必要的上下文", exampleType: "text", color: "cyan" },
  { label: "限制输出", description: "设置 max_tokens 防止响应过长", example: "摘要使用 max_tokens: 500", exampleType: "text", color: "cyan" },
  { label: "使用流式输出", description: "更快获得第一个 token，更好的用户体验", example: "任何超过 100 tokens 的响应都使用流式", exampleType: "text", color: "cyan" },
  { label: "积极缓存", description: "不要重复计算相同的查询", example: "缓存常见问题、模板输出", exampleType: "text", color: "cyan" }
]} />

## 成本优化

在规模化运营时，小的节省会累积成显著的预算影响。

### 理解成本

使用此计算器估算不同模型的 API 成本：

<CostCalculatorDemo />

### 成本降低策略

<InfoGrid items={[
  { label: "模型路由", description: "只在需要时使用昂贵的模型", example: "简单问题 → GPT-4o-mini，复杂问题 → GPT-4", exampleType: "text", color: "green" },
  { label: "提示词效率", description: "更短的提示词 = 更低的每次请求成本", example: "减少 50% 的 token = 节省 50% 的输入成本", exampleType: "text", color: "green" },
  { label: "输出控制", description: "当不需要完整细节时限制响应长度", example: "\"Answer in 2-3 sentences\" vs. 无限制", color: "green" },
  { label: "批处理", description: "将相关查询合并到单个请求中", example: "在一个提示词中分析 10 个项目 vs. 10 次单独调用", exampleType: "text", color: "green" },
  { label: "预过滤", description: "不要发送不需要 AI 的请求", example: "在昂贵的分类之前使用关键词匹配", exampleType: "text", color: "green" }
]} />

## 优化循环

优化是迭代的。这是一个系统性的过程：

### 第一步：建立基准

你无法改进你没有衡量的东西。在改变任何事情之前，严格记录你的起点。

<InfoGrid items={[
  { label: "提示词文档", description: "保存精确的提示词文本，包括系统提示词和任何模板", example: "像管理代码一样对提示词进行版本控制", exampleType: "text", color: "blue" },
  { label: "测试集", description: "创建 20-50 个代表性输入，涵盖常见情况和边缘情况", example: "包含简单、中等和困难的示例", exampleType: "text", color: "blue" },
  { label: "质量指标", description: "根据你的成功标准对每个输出评分", example: "准确率 %、相关性评分、格式合规性", exampleType: "text", color: "purple" },
  { label: "性能指标", description: "测量每个测试用例的 token 和时间", example: "平均输入：450 tokens，平均输出：200 tokens，p50 延迟：1.2s", exampleType: "text", color: "purple" }
]} />

<TryIt 
  title="基准文档模板"
  description="在优化之前使用此模板创建全面的基准。"
  prompt={`为我的提示词优化项目创建基准文档。

**当前提示词**：
"\${currentPrompt}"

**提示词的功能**：\${promptPurpose}

**我看到的当前问题**：\${currentIssues}

生成一个基准文档模板，包含：

1. **提示词快照**：精确的提示词文本（用于版本控制）

2. **测试用例**：建议我应该使用的 10 个代表性测试输入，涵盖：
   - 3 个典型/简单案例
   - 4 个中等复杂度案例
   - 3 个边缘案例或困难输入

3. **要跟踪的指标**：
   - 针对此用例的质量指标
   - 效率指标（tokens、延迟）
   - 如何对每个指标评分

4. **基准假设**：我预期当前性能是多少？

5. **成功标准**：什么数字会让我对优化感到满意？`}
/>

### 第二步：形成假设

<Compare 
  before={{ label: "模糊目标", content: "我想让我的提示词变得更好。" }}
  after={{ label: "可测试的假设", content: "如果我添加 2 个少样本示例，准确率将从 75% 提高到 85%，因为模型将学会预期的模式。" }}
/>

### 第三步：测试单一变更

一次只改变一件事。在相同的测试输入上运行两个版本。衡量重要的指标。

### 第四步：分析并决策

有效吗？保留更改。有害吗？还原。中性的？还原（简单更好）。

### 第五步：重复

根据你学到的内容生成新的假设。持续迭代，直到达到目标或收益递减。

## 优化清单

<Checklist 
  title="部署优化后的提示词之前"
  items={[
    { text: "定义了明确的成功指标" },
    { text: "测量了基准性能" },
    { text: "在代表性输入上测试了更改" },
    { text: "验证了质量没有退化" },
    { text: "检查了边缘情况处理" },
    { text: "计算了预期规模下的成本" },
    { text: "测试了负载下的延迟" },
    { text: "记录了更改的内容和原因" }
  ]}
/>

<Quiz 
  question="你有一个效果很好但规模化时成本太高的提示词。你应该首先做什么？"
  options={[
    "立即切换到更便宜的模型",
    "从提示词中删除词语以减少 token",
    "测量提示词的哪个部分使用了最多的 token",
    "为所有请求添加缓存"
  ]}
  correctIndex={2}
  explanation="在优化之前，先测量。你需要了解 token 花在哪里，然后才能有效地减少它们。提示词可能有不必要的上下文、冗长的指令，或生成比需要的更长的输出。测量告诉你应该把优化工作集中在哪里。"
/>
