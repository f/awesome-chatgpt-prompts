Obtener resultados consistentes y bien formateados es esencial para aplicaciones en producci√≥n y flujos de trabajo eficientes. Este cap√≠tulo cubre t√©cnicas para controlar exactamente c√≥mo los modelos de IA formatean sus respuestas.

<Callout type="info" title="De Prosa a Datos">
La salida estructurada transforma las respuestas de IA de texto libre en datos procesables y parseables.
</Callout>

## Por Qu√© Importa la Estructura

<StructuredOutputDemo />

## T√©cnicas B√°sicas de Formateo

### Listas

Las listas son perfectas para instrucciones paso a paso, elementos ordenados por rango o colecciones de puntos relacionados. Son f√°ciles de escanear y parsear. Usa **listas numeradas** cuando el orden importa (pasos, rankings) y **vi√±etas** para colecciones sin orden espec√≠fico.

<TryIt 
  compact
  title="Formateo de Listas"
  prompt={`Proporciona 5 consejos para dormir mejor.

Formato: Lista numerada con una breve explicaci√≥n para cada uno.
Cada consejo debe estar en negrita, seguido de un gui√≥n y la explicaci√≥n.`}
/>

<Callout type="tip" title="Mejores Pr√°cticas para Listas">
Especifica el n√∫mero exacto de elementos que quieres, si incluir explicaciones, y si los elementos deben estar en negrita o tener una estructura espec√≠fica.
</Callout>

### Tablas

Las tablas destacan al comparar m√∫ltiples elementos con las mismas dimensiones. Son ideales para comparaciones de caracter√≠sticas, res√∫menes de datos y cualquier informaci√≥n con atributos consistentes. Siempre define tus encabezados de columna expl√≠citamente.

<TryIt 
  compact
  title="Formateo de Tablas"
  prompt={`Compara los 4 principales frameworks web de Python.

Formatea como una tabla markdown con columnas:
| Framework | Mejor Para | Curva de Aprendizaje | Rendimiento |`}
/>

<Callout type="tip" title="Mejores Pr√°cticas para Tablas">
Especifica los nombres de las columnas, los tipos de datos esperados (texto, n√∫meros, calificaciones) y cu√°ntas filas necesitas. Para comparaciones complejas, lim√≠tate a 4-6 columnas para legibilidad.
</Callout>

### Encabezados y Secciones

Los encabezados crean una estructura clara del documento, haciendo que las respuestas largas sean escaneables y organizadas. √ösalos para informes, an√°lisis o cualquier respuesta de m√∫ltiples partes. Los encabezados jer√°rquicos (##, ###) muestran las relaciones entre secciones.

```
Analiza esta propuesta de negocio.

Estructura tu respuesta con estas secciones:
## Resumen Ejecutivo
## Fortalezas
## Debilidades
## Recomendaciones
## Evaluaci√≥n de Riesgos
```

<Callout type="tip" title="Mejores Pr√°cticas para Secciones">
Lista tus secciones en el orden que las quieres. Para consistencia, especifica qu√© debe contener cada secci√≥n (ej., "Resumen Ejecutivo: solo 2-3 oraciones").
</Callout>

### √ânfasis con Directivas en May√∫sculas

Las palabras en may√∫sculas act√∫an como se√±ales fuertes para el modelo, enfatizando restricciones o requisitos cr√≠ticos. √ösalas con moderaci√≥n para m√°ximo impacto‚Äîel uso excesivo diluye su efectividad.

**Directivas Comunes en May√∫sculas:**

<InfoGrid items={[
  { label: "NUNCA", description: "Prohibici√≥n absoluta: \"NUNCA incluyas opiniones personales\"", color: "red" },
  { label: "SIEMPRE", description: "Requisito obligatorio: \"SIEMPRE cita las fuentes\"", color: "green" },
  { label: "IMPORTANTE", description: "Instrucci√≥n cr√≠tica: \"IMPORTANTE: Mant√©n las respuestas bajo 100 palabras\"", color: "amber" },
  { label: "NO", description: "Prohibici√≥n fuerte: \"NO inventes estad√≠sticas\"", color: "red" },
  { label: "DEBE", description: "Acci√≥n requerida: \"La salida DEBE ser JSON v√°lido\"", color: "blue" },
  { label: "SOLO", description: "Restricci√≥n: \"Devuelve SOLO el c√≥digo, sin explicaciones\"", color: "purple" },
]} />

```
Resume este art√≠culo.

IMPORTANTE: Mant√©n el resumen bajo 100 palabras.
NUNCA agregues informaci√≥n que no est√© presente en el original.
SIEMPRE mant√©n el tono y perspectiva original.
NO incluyas tus propias opiniones o an√°lisis.
```

<Callout type="warning" title="Usa con Moderaci√≥n">
Si todo est√° en may√∫sculas o marcado como cr√≠tico, nada destaca. Reserva estas directivas para restricciones genuinamente importantes.
</Callout>

## Salida JSON

JSON (JavaScript Object Notation) es el formato m√°s popular para salida estructurada de IA. Es legible por m√°quinas, ampliamente soportado por lenguajes de programaci√≥n y perfecto para APIs, bases de datos y flujos de trabajo de automatizaci√≥n. La clave para JSON confiable es proporcionar un esquema claro.

### Solicitud JSON B√°sica

Comienza con una plantilla mostrando la estructura exacta que quieres. Incluye nombres de campos, tipos de datos y valores de ejemplo. Esto act√∫a como un contrato que el modelo seguir√°.

<TryIt 
  title="Extracci√≥n JSON"
  description="Extrae datos estructurados de texto no estructurado."
  prompt={`Extrae informaci√≥n de este texto y devu√©lvelo como JSON:

{
    "nombre_empresa": "string",
    "a√±o_fundacion": n√∫mero,
    "sede_central": "string",
    "empleados": n√∫mero,
    "industria": "string"
}

Texto: "Apple Inc., fundada en 1976, tiene su sede en Cupertino, California. El gigante tecnol√≥gico emplea aproximadamente 164,000 personas en todo el mundo."`}
/>

### Estructuras JSON Complejas

Para datos anidados, usa JSON jer√°rquico con objetos dentro de objetos, arrays de objetos y tipos mixtos. Define cada nivel claramente y usa anotaciones estilo TypeScript (`"positive" | "negative"`) para restringir valores.

```
Analiza esta rese√±a de producto y devuelve JSON:

{
  "id_resena": "string (genera √∫nico)",
  "sentimiento": {
    "general": "positivo" | "negativo" | "mixto" | "neutral",
    "puntuacion": 0.0-1.0
  },
  "aspectos": [
    {
      "aspecto": "string (ej., 'precio', 'calidad')",
      "sentimiento": "positivo" | "negativo" | "neutral",
      "menciones": ["citas exactas de la rese√±a"]
    }
  ],
  "intencion_compra": {
    "recomendaria": boolean,
    "confianza": 0.0-1.0
  },
  "frases_clave": ["array de strings con frases notables"]
}

Devuelve SOLO JSON v√°lido, sin texto adicional.

Rese√±a: "[texto de rese√±a]"
```

### Asegurando JSON V√°lido

Los modelos a veces agregan texto explicativo o formato markdown alrededor del JSON. Prev√©n esto con instrucciones expl√≠citas sobre el formato de salida. Puedes solicitar JSON crudo o JSON dentro de bloques de c√≥digo‚Äîelige seg√∫n tus necesidades de parseo.

Agrega instrucciones expl√≠citas:

```
IMPORTANTE:
- Devuelve SOLO el objeto JSON, sin bloques de c√≥digo markdown
- Aseg√∫rate de que todas las strings est√©n correctamente escapadas
- Usa null para valores faltantes, no undefined
- Valida que la salida sea JSON parseable
```

O solicita bloques de c√≥digo pidiendo al modelo que envuelva su salida:

````
Devuelve el resultado como un bloque de c√≥digo JSON:
```json
{ ... }
```
````

## Salida YAML

YAML es m√°s legible por humanos que JSON, usando indentaci√≥n en lugar de corchetes. Es el est√°ndar para archivos de configuraci√≥n (Docker, Kubernetes, GitHub Actions) y funciona bien cuando la salida ser√° le√≠da por humanos o usada en contextos DevOps. YAML es sensible a la indentaci√≥n, as√≠ que s√© espec√≠fico sobre los requisitos de formateo.

<TryIt 
  compact
  title="Generaci√≥n YAML"
  prompt={`Genera un workflow de GitHub Actions para un proyecto Node.js.

Devuelve como YAML v√°lido:
- Incluye: etapas de instalaci√≥n, lint, test, build
- Usa Node.js 18
- Cachea las dependencias npm
- Ejecuta en push a main y pull requests`}
/>

## Salida XML

XML todav√≠a se requiere para muchos sistemas empresariales, APIs SOAP e integraciones legacy. Es m√°s verboso que JSON pero ofrece caracter√≠sticas como atributos, namespaces y secciones CDATA para datos complejos. Especifica nombres de elementos, estructura de anidamiento y d√≥nde usar atributos vs. elementos hijo.

```
Convierte estos datos a formato XML:

Requisitos:
- Elemento ra√≠z: <catalogo>
- Cada √≠tem en elemento <libro>
- Incluye atributos donde sea apropiado
- Usa CDATA para texto de descripci√≥n

Datos: [datos del libro]
```

## Formatos Personalizados

A veces los formatos est√°ndar no se ajustan a tus necesidades. Puedes definir cualquier formato personalizado proporcionando una plantilla clara. Los formatos personalizados funcionan bien para informes, logs o salidas espec√≠ficas del dominio que ser√°n le√≠das por humanos.

### Formato de An√°lisis Estructurado

Usa delimitadores (===, ---, [SECCI√ìN]) para crear documentos escaneables con l√≠mites claros entre secciones. Este formato es genial para revisiones de c√≥digo, auditor√≠as y an√°lisis.

```
Analiza este c√≥digo usando este formato exacto:

=== AN√ÅLISIS DE C√ìDIGO ===

[RESUMEN]
Un p√°rrafo de descripci√≥n general

[PROBLEMAS]
‚Ä¢ CR√çTICO: [problema] ‚Äî [archivo:l√≠nea]
‚Ä¢ ADVERTENCIA: [problema] ‚Äî [archivo:l√≠nea]  
‚Ä¢ INFO: [problema] ‚Äî [archivo:l√≠nea]

[M√âTRICAS]
Complejidad: [Baja/Media/Alta]
Mantenibilidad: [puntuaci√≥n]/10
Cobertura de Tests: [% estimado]

[RECOMENDACIONES]
1. [Recomendaci√≥n prioridad 1]
2. [Recomendaci√≥n prioridad 2]

=== FIN AN√ÅLISIS ===
```

### Formato de Rellenar Espacios

Las plantillas con espacios en blanco (___) gu√≠an al modelo para completar campos espec√≠ficos mientras mantienen el formato exacto. Este enfoque es excelente para formularios, briefs y documentos estandarizados donde la consistencia importa.

```
Completa esta plantilla para el producto dado:

BRIEF DE PRODUCTO
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Nombre: _______________
Eslogan: _______________
Usuario Objetivo: _______________
Problema Resuelto: _______________
Caracter√≠sticas Clave:
  1. _______________
  2. _______________
  3. _______________
Diferenciador: _______________

Producto: [descripci√≥n del producto]
```

## Respuestas Tipadas

Las respuestas tipadas definen categor√≠as o tipos de entidades que el modelo debe reconocer y etiquetar. Esta t√©cnica es esencial para Reconocimiento de Entidades Nombradas (NER), tareas de clasificaci√≥n y cualquier extracci√≥n donde necesites categorizar informaci√≥n consistentemente. Define tus tipos claramente con ejemplos.

<TryIt 
  compact
  title="Extracci√≥n de Entidades"
  prompt={`Extrae entidades de este texto.

Tipos de Entidad:
- PERSONA: Nombres completos de personas
- ORG: Nombres de organizaciones/empresas
- UBICACI√ìN: Ciudades, pa√≠ses, direcciones
- FECHA: Fechas en formato ISO (YYYY-MM-DD)
- DINERO: Cantidades monetarias con moneda

Formatea cada una como: [TIPO]: [valor]

Texto: "Tim Cook anunci√≥ que Apple invertir√° $1 bill√≥n en una nueva instalaci√≥n en Austin para diciembre de 2024."`}
/>

## Respuestas Estructuradas Multi-Parte

Cuando necesitas salida completa cubriendo m√∫ltiples aspectos, define partes distintas con l√≠mites claros. Especifica exactamente qu√© va en cada parte‚Äîformato, longitud y tipo de contenido. Esto previene que el modelo mezcle secciones u omita partes.

```
Investiga este tema y proporciona:

### PARTE 1: RESUMEN EJECUTIVO
[Descripci√≥n general de 2-3 oraciones]

### PARTE 2: HALLAZGOS CLAVE
[Exactamente 5 vi√±etas]

### PARTE 3: TABLA DE DATOS
| M√©trica | Valor | Fuente |
|---------|-------|--------|
[Incluir m√≠nimo 5 filas]

### PARTE 4: RECOMENDACIONES
[Lista numerada de 3 recomendaciones accionables]

### PARTE 5: LECTURAS ADICIONALES
[3 recursos sugeridos con breves descripciones]
```

## Formateo Condicional

El formateo condicional te permite definir diferentes formatos de salida basados en las caracter√≠sticas de la entrada. Esto es poderoso para sistemas de clasificaci√≥n, triaje y enrutamiento donde el formato de respuesta debe variar seg√∫n lo que el modelo detecte. Usa l√≥gica if/then clara con plantillas de salida expl√≠citas para cada caso.

<TryIt 
  compact
  title="Clasificaci√≥n de Tickets"
  prompt={`Clasifica este ticket de soporte.

Si es URGENTE (sistema ca√≠do, problema de seguridad, p√©rdida de datos):
  Devuelve: üî¥ URGENTE | [Categor√≠a] | [Acci√≥n Sugerida]

Si es ALTO (afecta m√∫ltiples usuarios, impacto en ingresos):
  Devuelve: üü† ALTO | [Categor√≠a] | [Acci√≥n Sugerida]

Si es MEDIO (usuario √∫nico afectado, existe soluci√≥n temporal):
  Devuelve: üü° MEDIO | [Categor√≠a] | [Acci√≥n Sugerida]

Si es BAJO (preguntas, solicitudes de funcionalidades):
  Devuelve: üü¢ BAJO | [Categor√≠a] | [Acci√≥n Sugerida]

Ticket: "No puedo iniciar sesi√≥n en mi cuenta. He intentado restablecer mi contrase√±a dos veces pero sigo recibiendo un error. Esto est√° bloqueando a todo mi equipo de acceder al dashboard."`}
/>

## Arrays y Listas en JSON

Extraer m√∫ltiples elementos en arrays requiere definici√≥n cuidadosa del esquema. Especifica la estructura del array, qu√© debe contener cada elemento y c√≥mo manejar casos l√≠mite (arrays vac√≠os, elementos √∫nicos). Incluir un campo de conteo ayuda a verificar la completitud.

```
Extrae todos los action items de esta transcripci√≥n de reuni√≥n.

Devuelve como array JSON:
{
  "action_items": [
    {
      "tarea": "string describiendo la tarea",
      "asignado": "nombre de persona o 'Sin asignar'",
      "fecha_limite": "fecha si se menciona, sino null",
      "prioridad": "alta" | "media" | "baja",
      "contexto": "cita relevante de la transcripci√≥n"
    }
  ],
  "total_count": n√∫mero
}

Transcripci√≥n: "[transcripci√≥n de reuni√≥n]"
```

## Instrucciones de Validaci√≥n

La auto-validaci√≥n indica al modelo que verifique su propia salida antes de responder. Esto detecta problemas comunes como secciones faltantes, texto de marcador de posici√≥n o violaciones de restricciones. El modelo iterar√° internamente para arreglar problemas, mejorando la calidad de la salida sin llamadas adicionales a la API.

```
Genera el informe, luego:

CHECKLIST DE VALIDACI√ìN:
‚ñ° Todas las secciones requeridas presentes
‚ñ° Sin texto de marcador de posici√≥n restante
‚ñ° Todas las estad√≠sticas incluyen fuentes
‚ñ° Conteo de palabras entre 500-700
‚ñ° La conclusi√≥n conecta con la introducci√≥n

Si alguna verificaci√≥n falla, corrige antes de responder.
```

## Manejo de Campos Opcionales

Los datos del mundo real a menudo tienen valores faltantes. Instruye expl√≠citamente al modelo sobre c√≥mo manejar campos opcionales‚Äîusar `null` es m√°s limpio que strings vac√≠os y m√°s f√°cil de procesar program√°ticamente. Tambi√©n previene la "alucinaci√≥n" de datos faltantes enfatizando que el modelo nunca debe inventar informaci√≥n.

```
Extrae informaci√≥n de contacto. Usa null para campos faltantes.

{
  "nombre": "string (requerido)",
  "email": "string o null",
  "telefono": "string o null", 
  "empresa": "string o null",
  "rol": "string o null",
  "linkedin": "string URL o null"
}

IMPORTANTE: 
- Nunca inventes informaci√≥n que no est√© en la fuente
- Usa null, no strings vac√≠os, para datos faltantes
- N√∫meros de tel√©fono en formato E.164 si es posible
```

## Resumen

<Callout type="tip" title="T√©cnicas Clave">
S√© expl√≠cito sobre el formato, usa ejemplos, especifica tipos, maneja casos l√≠mite con valores null y pide al modelo que valide su propia salida.
</Callout>

<Quiz 
  question="¬øCu√°l es la principal ventaja de la salida estructurada sobre el texto no estructurado?"
  options={[
    "Usa menos tokens",
    "Es m√°s f√°cil de generar para la IA",
    "Puede ser parseada program√°ticamente y validada",
    "Siempre produce informaci√≥n correcta"
  ]}
  correctIndex={2}
  explanation="Las salidas estructuradas como JSON pueden ser parseadas por c√≥digo, comparadas entre consultas, integradas en flujos de trabajo y validadas por completitud‚Äîcosas que son dif√≠ciles o imposibles con texto libre."
/>

Las salidas estructuradas son esenciales para construir aplicaciones fiables impulsadas por IA. En el pr√≥ximo cap√≠tulo, exploraremos el prompting de cadena de pensamiento para tareas de razonamiento complejo.
