KI hat die Softwareentwicklung transformiert. Este cap√≠tulo behandelt Prompting-Techniken f√ºr Code-Generierung, Debugging, Review und Entwicklungs-Workflows.

<Callout type="info" title="KI als Coding-Partner">
KI gl√§nzt bei Code-Generierung, Debugging und Dokumentation‚Äîaber √ºberpr√ºfe generierten Code immer auf Sicherheit, Korrektheit und Wartbarkeit. Deploye niemals KI-Code ohne Tests.
</Callout>

## Code-Generierung

### Do's und Don'ts: Code-Prompts

<Compare 
  before={{ label: "‚ùå Vage Anfrage", content: "Schreib eine Funktion, um E-Mails zu validieren." }}
  after={{ label: "‚úì Vollst√§ndige Spezifikation", content: "Schreib eine Python-Funktion, die E-Mail-Adressen validiert.\n\nInput: string (potenzielle E-Mail)\nOutput: tuple[bool, str | None] - (is_valid, error_message)\nBehandle: leerer String, None, Unicode-Zeichen\nVerwende Regex, inkludiere Type Hints und Docstring." }}
/>

### Funktions-Generierung

<TryIt compact prompt={`Schreib eine \${sprache:Python}-Funktion, die \${beschreibung:E-Mail-Adressen validiert}.

Anforderungen:
- Input: \${inputTypen:string (potenzielle E-Mail)}
- Output: \${outputTyp:boolean und optionale Fehlermeldung}
- Behandle Edge Cases: \${edgeCases:leerer String, None, Unicode-Zeichen}
- Performance: \${performance:standard}

Inkludiere:
- Type Hints/Annotations
- Docstring mit Ejemploen
- Input-Validierung
- Fehlerbehandlung`} />

### Klassen/Modul-Generierung

<TryIt compact prompt={`Erstelle eine \${sprache:Python}-Klasse f√ºr \${zweck:das Verwalten von User-Sessions}.

Klassen-Design:
- Name: \${klassenName:SessionManager}
- Verantwortlichkeit: \${verantwortlichkeit:User-Session-Lifecycle handhaben}
- Properties: \${properties:session_id, user_id, created_at, expires_at}
- Methoden: \${methoden:create(), validate(), refresh(), destroy()}

Anforderungen:
- Folge \${designPattern:Singleton}-Pattern
- Inkludiere saubere Kapselung
- F√ºge umfassende Docstrings hinzu
- Inkludiere Nutzungsbeispiel

Testing:
- Inkludiere Unit-Test-Ger√ºst`} />

## Debugging

<Callout type="tip" title="Debugging-Prinzip">
Inkludiere immer das **erwartete Verhalten**, **tats√§chliche Verhalten** und die **Fehlermeldung** (falls vorhanden). Je mehr Kontext du lieferst, desto schneller kann KI die Ursache identifizieren.
</Callout>

### Bug-Analyse

<TryIt compact prompt={`Debugge diesen Code. Er sollte \${erwartetes:die Summe aller Zahlen zur√ºckgeben}, aber stattdessen \${tatsaechliches:gibt er 0 f√ºr alle Eingaben zur√ºck}.

Code:
\${code:f√ºge deinen Code hier ein}

Fehlermeldung (falls vorhanden):
\${fehler:keine}

Debugging-Schritte:
1. Identifiziere, was der Code versucht zu tun
2. Verfolge die Ausf√ºhrung mit gegebener Eingabe
3. Finde, wo erwartetes und tats√§chliches Verhalten divergieren
4. Erkl√§re die Ursache
5. Liefere die L√∂sung mit Erkl√§rung`} />

### Fehlermeldungs-Interpretation

<TryIt compact prompt={`Erkl√§re diesen Fehler und wie man ihn behebt:

Fehler:
\${fehlerMeldung:f√ºge Fehlermeldung oder Stack-Trace ein}

Contexto:
- Sprache/Framework: \${framework:Python 3.11}
- Was ich versucht habe: \${aktion:eine JSON-Datei zu lesen}
- Relevanter Code: \${codeSnippet:f√ºge relevanten Code ein}

Liefere:
1. Verst√§ndliche Erkl√§rung des Fehlers
2. Ursache
3. Schritt-f√ºr-Schritt-L√∂sung
4. Wie man das in Zukunft verhindert`} />

## Code Review

### Do's und Don'ts: Code-Review-Prompts

<Compare 
  before={{ label: "‚ùå Generische Anfrage", content: "Review diesen Code." }}
  after={{ label: "‚úì Spezifische Kriterien", content: "Review diesen Code f√ºr einen Pull Request.\n\nPr√ºfe auf:\n1. Korrektheit: Bugs, Logikfehler, Edge Cases\n2. Sicherheit: Injection-Risiken, Auth-Probleme\n3. Performance: N+1-Queries, Memory-Leaks\n4. Wartbarkeit: Benennung, Komplexit√§t\n\nFormato: üî¥ Kritisch / üü° Wichtig / üü¢ Vorschlag" }}
/>

### Umfassendes Review

<TryIt compact prompt={`Review diesen Code f√ºr einen Pull Request.

Code:
\${code:f√ºge deinen Code ein}

Review auf:
1. **Korrektheit**: Bugs, Logikfehler, Edge Cases
2. **Sicherheit**: Schwachstellen, Injection-Risiken, Auth-Probleme
3. **Performance**: Ineffizienzen, N+1-Queries, Memory-Leaks
4. **Wartbarkeit**: Lesbarkeit, Benennung, Komplexit√§t
5. **Best Practices**: \${framework:Python/Django}-Konventionen

Formatiere dein Review als:
üî¥ Kritisch: muss vor Merge behoben werden
üü° Wichtig: sollte behoben werden
üü¢ Vorschlag: nice to have
üí≠ Frage: Kl√§rung n√∂tig`} />

### Sicherheits-Review

<TryIt compact prompt={`F√ºhre ein Sicherheits-Review dieses Codes durch:

Code:
\${code:f√ºge deinen Code ein}

Pr√ºfe auf:
- [ ] Injection-Schwachstellen (SQL, XSS, Command)
- [ ] Authentifizierungs-/Autorisierungsfehler
- [ ] Offenlegung sensibler Daten
- [ ] Unsichere Dependencies
- [ ] Kryptografische Probleme
- [ ] Input-Validierungs-L√ºcken
- [ ] Fehlerbehandlung, die Info leakt

F√ºr jeden Fund:
- Schweregrad: Kritisch/Hoch/Mittel/Niedrig
- Ort: Zeilennummer oder Funktion
- Problem: Beschreibung
- Exploit: Wie es ausgenutzt werden k√∂nnte
- Fix: Empfohlene Behebung`} />

## Refactoring

### Code-Smell-Erkennung

<TryIt compact prompt={`Analysiere diesen Code auf Code Smells und Refactoring-M√∂glichkeiten:

Code:
\${code:f√ºge deinen Code ein}

Identifiziere:
1. Lange Methoden (schlage Extraktion vor)
2. Duplizierter Code (schlage DRY-Verbesserungen vor)
3. Komplexe Conditionals (schlage Vereinfachung vor)
4. Schlechte Benennung (schlage bessere Namen vor)
5. Enge Kopplung (schlage Entkopplung vor)

F√ºr jedes Problem zeige Vorher/Nachher-Code.`} />

## Testing

### Unit-Test-Generierung

<TryIt compact prompt={`Schreib Unit-Tests f√ºr diese Funktion:

Funktion:
\${code:f√ºge deine Funktion ein}

Testing-Framework: \${testFramework:pytest}

Abdecken:
- Happy Path (normale Eingaben)
- Edge Cases (leer, null, Grenzwerte)
- Fehlerf√§lle (ung√ºltige Eingaben)
- \${spezifischeScenarien:gleichzeitiger Zugriff, gro√üe Eingaben}

Formato: Arrange-Act-Assert-Pattern
Inkludiere: Beschreibende Testnamen`} />

## Architektur & Design

### System-Design

<TryIt compact prompt={`Designe ein System f√ºr \${anforderung:Echtzeit-Chat-Anwendung}.

Restricciones:
- Erwartete Last: \${erwartete Last:10.000 gleichzeitige Nutzer}
- Latenz-Anforderungen: \${latenz:< 100ms Nachrichtenzustellung}
- Verf√ºgbarkeit: \${verfuegbarkeit:99,9%}
- Budget: \${budget:moderat, bevorzuge Open Source}

Liefere:
1. High-Level-Architekturdiagramm (ASCII/Text)
2. Komponenten-Beschreibungen
3. Datenfluss
4. Technologie-Wahlen mit Begr√ºndung
5. Skalierungsstrategie
6. Trade-offs und betrachtete Alternativen`} />

## Dokumentations-Generierung

### API-Dokumentation

<TryIt compact prompt={`Generiere API-Dokumentation aus diesem Code:

Code:
\${code:f√ºge deinen Endpoint-Code ein}

Formato: \${format:OpenAPI/Swagger YAML}

Inkludiere:
- Endpoint-Beschreibung
- Request/Response-Schemas
- Ejemplo-Requests/Responses
- Fehlercodes
- Authentifizierungs-Anforderungen`} />

## Prompt-Vorlagen von prompts.chat

### Agiere als Senior Developer

```
Ich m√∂chte, dass du als Senior Software Developer agierst. Ich werde 
Code bereitstellen und Fragen dazu stellen. Du wirst den Code reviewen, 
Verbesserungen vorschlagen, Konzepte erkl√§ren und beim Debuggen helfen. 
Deine Antworten sollten lehrreich sein und mir helfen, ein besserer 
Entwickler zu werden.
```

### Agiere als Code Reviewer

```
Ich m√∂chte, dass du als Code Reviewer agierst. Ich werde Pull Requests 
mit Code-√Ñnderungen bereitstellen, und du wirst sie gr√ºndlich reviewen. 
Pr√ºfe auf Bugs, Sicherheitsprobleme, Performance-Probleme und Einhaltung 
von Best Practices. Gib konstruktives Feedback, das dem Entwickler hilft, 
sich zu verbessern.
```

## Entwicklungs-Workflow-Integration

### Commit-Message-Generierung

<TryIt compact prompt={`Generiere eine Commit-Message f√ºr diese √Ñnderungen:

Diff:
\${diff:f√ºge git diff ein}

Formato: Conventional Commits
Typ: \${commitTyp:feat}

Liefere:
- Betreffzeile (max 50 Zeichen, Imperativ)
- Body (was und warum, bei 72 Zeichen umbrechen)
- Footer (Issues referenzieren falls zutreffend)`} />

### PR-Beschreibungs-Generierung

<TryIt compact prompt={`Generiere eine Pull-Request-Beschreibung:

√Ñnderungen:
\${aenderungen:liste deine √Ñnderungen oder f√ºge diff-Resumen ein}

Template:
## Resumen
Kurze Beschreibung der √Ñnderungen

## Vorgenommene √Ñnderungen
- √Ñnderung 1
- √Ñnderung 2

## Testing
- [ ] Unit-Tests hinzugef√ºgt/aktualisiert
- [ ] Manuelles Testen abgeschlossen

## Screenshots (bei UI-√Ñnderungen)
Platzhalter

## Verwandte Issues
Schlie√üt #\${issueNummer:123}`} />

## Resumen

<Callout type="tip" title="T√©cnicas clave">
Inkludiere vollst√§ndigen Kontext (Sprache, Framework, Einschr√§nkungen), spezifiziere Anforderungen pr√§zise, fordere spezifische Ausgabeformate an, bitte um Erkl√§rungen neben dem Code, und inkludiere zu behandelnde Edge Cases.
</Callout>

<Quiz 
  question="Was ist das wichtigste Element, das man einschlie√üen sollte, wenn man KI bittet, Code zu debuggen?"
  options={[
    "Nur die Programmiersprache",
    "Erwartetes Verhalten, tats√§chliches Verhalten und Fehlermeldung",
    "Nur das Code-Snippet",
    "Der Dateiname"
  ]}
  correctIndex={1}
  explanation="Debugging erfordert Contexto: was sollte passieren vs. was tats√§chlich passiert. Fehlermeldungen und Stack-Traces helfen KI, das genaue Problem schnell zu lokalisieren."
/>

KI ist ein m√§chtiger Coding-Partner‚Äînutze sie f√ºr Generierung, Review, Debugging und Dokumentation, w√§hrend du dein architektonisches Urteil beibeh√§ltst.
