KI hat die Softwareentwicklung transformiert. Dieses Kapitel behandelt Prompting-Techniken f√ºr Code-Generierung, Debugging, Review und Entwicklungs-Workflows.

<Callout type="info" title="KI als Coding-Partner">
KI zeichnet sich bei Code-Generierung, Debugging und Dokumentation aus ‚Äì aber √ºberpr√ºfe generierten Code immer auf Sicherheit, Korrektheit und Wartbarkeit. Deploye niemals KI-Code ohne Testen.
</Callout>

## Code-Generierung

### Dos and Don'ts: Code-Prompts

<Compare 
  before={{ label: "‚ùå Vage Anfrage", content: "Schreib eine Funktion zum Validieren von E-Mails." }}
  after={{ label: "‚úì Vollst√§ndige Spezifikation", content: "Schreib eine Python-Funktion, die E-Mail-Adressen validiert.\n\nInput: string (potenzielle E-Mail)\nOutput: tuple[bool, str | None] - (is_valid, error_message)\nHandle: leerer String, None, Unicode-Zeichen\nVerwende Regex, f√ºge Type Hints und Docstring ein." }}
/>

### Funktions-Generierung

<TryIt compact prompt={`Schreib eine \${language:Python}-Funktion, die \${description:E-Mail-Adressen validiert}.

Anforderungen:
- Input: \${inputTypes:string (potenzielle E-Mail)}
- Output: \${outputType:boolean und optionale Fehlermeldung}
- Handle Edge Cases: \${edgeCases:leerer String, None, Unicode-Zeichen}
- Performance: \${performance:standard}

Enthalten:
- Type Hints/Annotations
- Docstring mit Beispielen
- Input-Validierung
- Fehlerbehandlung`} />

### Klassen-/Modul-Generierung

<TryIt compact prompt={`Erstelle eine \${language:Python}-Klasse f√ºr \${purpose:Verwaltung von Benutzer-Sessions}.

Klassen-Design:
- Name: \${className:SessionManager}
- Verantwortlichkeit: \${responsibility:Benutzer-Session-Lebenszyklus handhaben}
- Eigenschaften: \${properties:session_id, user_id, created_at, expires_at}
- Methoden: \${methods:create(), validate(), refresh(), destroy()}

Anforderungen:
- Folge \${designPattern:Singleton}-Pattern
- F√ºge korrekte Kapselung ein
- F√ºge umfassende Docstrings hinzu
- F√ºge Verwendungsbeispiel ein

Testing:
- F√ºge Unit-Test-Skelett ein`} />

### API-Endpoint-Generierung

<TryIt compact prompt={`Erstelle einen REST-API-Endpoint f√ºr \${resource:Benutzerprofile}.

Framework: \${framework:FastAPI}
Methode: \${method:GET}
Pfad: \${path:/api/users/{id}}

Request:
- Header: \${headers:Authorization Bearer token}
- Body-Schema: \${bodySchema:N/A f√ºr GET}
- Query-Parameter: \${queryParams:include_posts (boolean)}

Response:
- Erfolg: \${successResponse:200 mit User-Objekt}
- Fehler: \${errorResponses:401 Unauthorized, 404 Not Found}

Enthalten:
- Input-Validierung
- Authentifizierungspr√ºfung
- Fehlerbehandlung
- Rate-Limiting-Ber√ºcksichtigung`} />

## Debugging

<Callout type="tip" title="Debugging-Prinzip">
Schlie√üe immer das **erwartete Verhalten**, **tats√§chliche Verhalten** und die **Fehlermeldung** (falls vorhanden) ein. Je mehr Kontext du lieferst, desto schneller kann KI die Ursache identifizieren.
</Callout>

### Bug-Analyse

<TryIt compact prompt={`Debugge diesen Code. Er sollte \${expectedBehavior:die Summe aller Zahlen zur√ºckgeben}, aber stattdessen \${actualBehavior:gibt 0 f√ºr alle Eingaben zur√ºck}.

Code:
\${code:f√ºge deinen Code hier ein}

Fehlermeldung (falls vorhanden):
\${error:keine}

Debugging-Schritte:
1. Identifiziere, was der Code versucht zu tun
2. Verfolge die Ausf√ºhrung mit der gegebenen Eingabe
3. Finde, wo erwartetes und tats√§chliches Verhalten divergieren
4. Erkl√§re die Ursache
5. Liefere den Fix mit Erkl√§rung`} />

### Fehlermeldungs-Interpretation

<TryIt compact prompt={`Erkl√§re diesen Fehler und wie man ihn behebt:

Fehler:
\${errorMessage:f√ºge Fehlermeldung oder Stack-Trace hier ein}

Kontext:
- Sprache/Framework: \${framework:Python 3.11}
- Was ich versucht habe: \${action:eine JSON-Datei lesen}
- Relevanter Code: \${codeSnippet:f√ºge relevanten Code ein}

Liefere:
1. Erkl√§rung des Fehlers in einfacher Sprache
2. Ursache
3. Schritt-f√ºr-Schritt-Fix
4. Wie das in Zukunft zu verhindern ist`} />

### Performance-Debugging

<TryIt compact prompt={`Dieser Code ist langsam. Analysiere und optimiere:

Code:
\${code:f√ºge deinen Code hier ein}

Aktuelle Performance: \${currentPerformance:dauert 30 Sekunden f√ºr 1000 Items}
Ziel-Performance: \${targetPerformance:unter 5 Sekunden}
Einschr√§nkungen: \${constraints:Speicherlimit 512MB}

Liefere:
1. Identifiziere Engp√§sse
2. Erkl√§re, warum jeder langsam ist
3. Schlage Optimierungen vor (nach Auswirkung gerankt)
4. Zeige optimierten Code
5. Sch√§tze Verbesserung`} />

## Code Review

### Dos and Don'ts: Code-Review-Prompts

<Compare 
  before={{ label: "‚ùå Generische Anfrage", content: "√úberpr√ºfe diesen Code." }}
  after={{ label: "‚úì Spezifische Kriterien", content: "√úberpr√ºfe diesen Code f√ºr einen Pull Request.\n\nPr√ºfe auf:\n1. Korrektheit: Bugs, Logikfehler, Edge Cases\n2. Sicherheit: Injektionsrisiken, Auth-Probleme\n3. Performance: N+1 Queries, Speicherlecks\n4. Wartbarkeit: Benennung, Komplexit√§t\n\nFormat: üî¥ Kritisch / üü° Wichtig / üü¢ Vorschlag" }}
/>

### Umfassende Review

<TryIt compact prompt={`√úberpr√ºfe diesen Code f√ºr einen Pull Request.

Code:
\${code:f√ºge deinen Code hier ein}

√úberpr√ºfe auf:
1. **Korrektheit**: Bugs, Logikfehler, Edge Cases
2. **Sicherheit**: Schwachstellen, Injektionsrisiken, Auth-Probleme
3. **Performance**: Ineffizienzen, N+1 Queries, Speicherlecks
4. **Wartbarkeit**: Lesbarkeit, Benennung, Komplexit√§t
5. **Best Practices**: \${framework:Python/Django}-Konventionen

Formatiere deine Review als:
üî¥ Kritisch: muss vor Merge gefixt werden
üü° Wichtig: sollte gefixt werden
üü¢ Vorschlag: nice to have
üí≠ Frage: Kl√§rung n√∂tig`} />

### Sicherheits-Review

<TryIt compact prompt={`F√ºhre eine Sicherheits-Review dieses Codes durch:

Code:
\${code:f√ºge deinen Code hier ein}

Pr√ºfe auf:
- [ ] Injektions-Schwachstellen (SQL, XSS, Command)
- [ ] Authentifizierungs-/Autorisierungsfehler
- [ ] Sensible Daten-Exposition
- [ ] Unsichere Abh√§ngigkeiten
- [ ] Kryptografische Probleme
- [ ] Input-Validierungs-L√ºcken
- [ ] Fehlerbehandlung, die Infos leakt

F√ºr jedes Ergebnis:
- Schweregrad: Kritisch/Hoch/Mittel/Niedrig
- Ort: Zeilennummer oder Funktion
- Problem: Beschreibung
- Exploit: Wie es angegriffen werden k√∂nnte
- Fix: Empfohlene Behebung`} />

## Refactoring

### Code-Smell-Erkennung

<TryIt compact prompt={`Analysiere diesen Code auf Code Smells und Refactoring-M√∂glichkeiten:

Code:
\${code:f√ºge deinen Code hier ein}

Identifiziere:
1. Lange Methoden (schlage Extraktion vor)
2. Duplikater Code (schlage DRY-Verbesserungen vor)
3. Komplexe Conditionals (schlage Vereinfachung vor)
4. Schlechte Benennung (schlage bessere Namen vor)
5. Enge Kopplung (schlage Entkopplung vor)

F√ºr jedes Problem, zeige Vorher/Nachher-Code.`} />

### Design-Pattern-Anwendung

<TryIt compact prompt={`Refaktoriere diesen Code mit dem \${patternName:Factory}-Pattern.

Aktueller Code:
\${code:f√ºge deinen Code hier ein}

Ziele:
- \${whyPattern:Objekterstellung von Verwendung entkoppeln}
- \${benefits:einfacheres Testen und Erweiterbarkeit}

Liefere:
1. Erkl√§rung des Patterns
2. Wie es hier anwendbar ist
3. Refaktorierter Code
4. Trade-offs zu beachten`} />

## Testing

### Unit-Test-Generierung

<TryIt compact prompt={`Schreibe Unit Tests f√ºr diese Funktion:

Funktion:
\${code:f√ºge deine Funktion hier ein}

Testing-Framework: \${testFramework:pytest}

Abdecke:
- Happy Path (normale Eingaben)
- Edge Cases (leer, null, Grenzwerte)
- Fehlerf√§lle (ung√ºltige Eingaben)
- \${specificScenarios:paralleler Zugriff, gro√üe Eingaben}

Format: Arrange-Act-Assert-Pattern
Enthalten: Beschreibende Testnamen`} />

### Testfall-Generierung

<TryIt compact prompt={`Generiere Testf√§lle f√ºr dieses Feature:

Feature: \${featureDescription:Benutzerregistrierung mit E-Mail-Verifizierung}
Akzeptanzkriterien: \${acceptanceCriteria:Benutzer kann sich anmelden, erh√§lt E-Mail, kann Account verifizieren}

Liefere Testf√§lle in diesem Format:

| ID | Szenario | Gegeben | Wenn | Dann | Priorit√§t |
|----|----------|---------|------|------|-----------|
| TC01 | ... | ... | ... | ... | Hoch |`} />

## Architektur & Design

### System-Design

<TryIt compact prompt={`Designe ein System f√ºr \${requirement:Echtzeit-Chat-Anwendung}.

Einschr√§nkungen:
- Erwartete Last: \${expectedLoad:10.000 gleichzeitige Benutzer}
- Latenz-Anforderungen: \${latency:< 100ms Nachrichtenzustellung}
- Verf√ºgbarkeit: \${availability:99,9%}
- Budget: \${budget:moderat, bevorzuge Open Source}

Liefere:
1. High-Level-Architekturdiagramm (ASCII/Text)
2. Komponenten-Beschreibungen
3. Datenfluss
4. Technologie-Entscheidungen mit Begr√ºndung
5. Skalierungsstrategie
6. Trade-offs und betrachtete Alternativen`} />

### Datenbank-Schema-Design

<TryIt compact prompt={`Designe ein Datenbank-Schema f√ºr \${application:E-Commerce-Plattform}.

Anforderungen:
- \${feature1:Benutzerkonten mit Profilen und Adressen}
- \${feature2:Produktkatalog mit Kategorien und Varianten}
- \${feature3:Bestellungen mit Positionen und Zahlungsverfolgung}

Liefere:
1. Entity-Relationship-Beschreibung
2. Tabellendefinitionen mit Spalten und Typen
3. Indizes f√ºr h√§ufige Abfragen
4. Fremdschl√ºssel-Beziehungen
5. Beispiel-Abfragen f√ºr Schl√ºsseloperationen`} />

## Dokumentations-Generierung

### API-Dokumentation

<TryIt compact prompt={`Generiere API-Dokumentation aus diesem Code:

Code:
\${code:f√ºge deinen Endpoint-Code hier ein}

Format: \${format:OpenAPI/Swagger YAML}

Enthalten:
- Endpoint-Beschreibung
- Request/Response-Schemas
- Beispiel-Requests/Responses
- Fehlercodes
- Authentifizierungs-Anforderungen`} />

### Inline-Dokumentation

<TryIt compact prompt={`F√ºge umfassende Dokumentation zu diesem Code hinzu:

Code:
\${code:f√ºge deinen Code hier ein}

Hinzuf√ºgen:
- Datei-/Modul-Docstring (Zweck, Verwendung)
- Funktions-/Methoden-Docstrings (Parameter, R√ºckgaben, Ausnahmen, Beispiele)
- Inline-Kommentare nur f√ºr komplexe Logik
- Type Hints, falls fehlend

Stil: \${docStyle:Google}`} />

## Prompt-Vorlagen von prompts.chat

### Agiere als Senior Developer

```
Ich m√∂chte, dass du als Senior Software Developer agierst. Ich werde 
Code bereitstellen und Fragen dazu stellen. Du wirst den Code √ºberpr√ºfen, 
Verbesserungen vorschlagen, Konzepte erkl√§ren und beim Debuggen helfen. 
Deine Antworten sollten lehrreich sein und mir helfen, ein besserer 
Entwickler zu werden.
```

### Agiere als Code Reviewer

```
Ich m√∂chte, dass du als Code Reviewer agierst. Ich werde Pull Requests 
mit Code-√Ñnderungen bereitstellen, und du wirst sie gr√ºndlich √ºberpr√ºfen. 
Pr√ºfe auf Bugs, Sicherheitsprobleme, Performance-Probleme und Einhaltung 
von Best Practices. Liefere konstruktives Feedback, das dem Entwickler 
hilft, sich zu verbessern.
```

### Agiere als Software Architect

```
Ich m√∂chte, dass du als Software Architect agierst. Ich werde 
Systemanforderungen und Einschr√§nkungen beschreiben, und du wirst 
skalierbare, wartbare Architekturen entwerfen. Erkl√§re deine 
Design-Entscheidungen, Trade-offs und liefere Diagramme, wo hilfreich.
```

## Entwicklungs-Workflow-Integration

### Commit-Message-Generierung

<TryIt compact prompt={`Generiere eine Commit-Message f√ºr diese √Ñnderungen:

Diff:
\${diff:f√ºge git diff hier ein}

Format: Conventional Commits
Typ: \${commitType:feat}

Liefere:
- Subject-Zeile (max. 50 Zeichen, Imperativ)
- Body (was und warum, umgebrochen bei 72 Zeichen)
- Footer (referenziert Issues falls zutreffend)`} />

### PR-Beschreibungs-Generierung

<TryIt compact prompt={`Generiere eine Pull-Request-Beschreibung:

√Ñnderungen:
\${changes:liste deine √Ñnderungen oder f√ºge Diff-Zusammenfassung ein}

Vorlage:
## Zusammenfassung
Kurze Beschreibung der √Ñnderungen

## Vorgenommene √Ñnderungen
- √Ñnderung 1
- √Ñnderung 2

## Testing
- [ ] Unit Tests hinzugef√ºgt/aktualisiert
- [ ] Manuelles Testing abgeschlossen

## Screenshots (falls UI-√Ñnderungen)
Platzhalter

## Verwandte Issues
Schlie√üt #\${issueNumber:123}`} />

## Zusammenfassung

<Callout type="tip" title="Schl√ºsseltechniken">
F√ºge vollen Kontext ein (Sprache, Framework, Einschr√§nkungen), spezifiziere Anforderungen pr√§zise, fordere spezifische Ausgabeformate an, bitte um Erkl√§rungen neben Code und schlie√üe zu behandelnde Edge Cases ein.
</Callout>

<Quiz 
  question="Was ist das wichtigste Element, wenn man KI bittet, Code zu debuggen?"
  options={[
    "Nur die Programmiersprache",
    "Erwartetes Verhalten, tats√§chliches Verhalten und Fehlermeldung",
    "Nur der Code-Ausschnitt",
    "Der Dateiname"
  ]}
  correctIndex={1}
  explanation="Debugging erfordert Kontext: was passieren sollte vs. was tats√§chlich passiert. Fehlermeldungen und Stack-Traces helfen KI, das genaue Problem schnell zu lokalisieren."
/>

KI ist ein m√§chtiger Coding-Partner ‚Äì nutze sie f√ºr Generierung, Review, Debugging und Dokumentation, w√§hrend du dein architektonisches Urteilsverm√∂gen beibeh√§ltst.
