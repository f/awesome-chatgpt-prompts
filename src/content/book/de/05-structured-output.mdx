Konsistente, gut formatierte Ausgaben zu erhalten ist essentiell f√ºr Produktionsanwendungen und effiziente Workflows. Dieses Kapitel behandelt Techniken zur genauen Kontrolle, wie KI-Modelle ihre Antworten formatieren.

<Callout type="info" title="Von Prosa zu Daten">
Strukturierte Ausgabe transformiert KI-Antworten von Freitext in verwertbare, parsbare Daten.
</Callout>

## Warum Struktur wichtig ist

<StructuredOutputDemo />

## Grundlegende Formatierungstechniken

### Listen

Listen sind perfekt f√ºr Schritt-f√ºr-Schritt-Anleitungen, Ranglisten oder Sammlungen zusammengeh√∂riger Punkte. Sie sind leicht zu √ºberfliegen und zu parsen. Verwende **nummerierte Listen** wenn die Reihenfolge wichtig ist (Schritte, Rankings) und **Aufz√§hlungspunkte** f√ºr ungeordnete Sammlungen.

<TryIt 
  compact
  title="Listen-Formatierung"
  prompt={`Gib 5 Tipps f√ºr besseren Schlaf.

Format: Nummerierte Liste mit kurzer Erkl√§rung f√ºr jeden.
Jeder Tipp sollte fett sein, gefolgt von einem Bindestrich und Erkl√§rung.`}
/>

<Callout type="tip" title="Listen Best Practices">
Gib die genaue Anzahl der gew√ºnschten Elemente an, ob Erkl√§rungen enthalten sein sollen, und ob Elemente fett oder in einer bestimmten Struktur sein sollen.
</Callout>

### Tabellen

Tabellen eignen sich hervorragend zum Vergleichen mehrerer Elemente √ºber dieselben Dimensionen. Sie sind ideal f√ºr Funktionsvergleiche, Datenzusammenfassungen und jede Information mit konsistenten Attributen. Definiere immer explizit deine Spalten√ºberschriften.

<TryIt 
  compact
  title="Tabellen-Formatierung"
  prompt={`Vergleiche die Top 4 Python Web-Frameworks.

Formatiere als Markdown-Tabelle mit Spalten:
| Framework | Beste F√ºr | Lernkurve | Performance |`}
/>

<Callout type="tip" title="Tabellen Best Practices">
Gib Spaltennamen, erwartete Datentypen (Text, Zahlen, Bewertungen) und wie viele Zeilen du brauchst an. F√ºr komplexe Vergleiche beschr√§nke dich auf 4-6 Spalten f√ºr bessere Lesbarkeit.
</Callout>

### √úberschriften und Abschnitte

√úberschriften schaffen eine klare Dokumentstruktur, die lange Antworten √ºbersichtlich und organisiert macht. Verwende sie f√ºr Berichte, Analysen oder jede mehrteilige Antwort. Hierarchische √úberschriften (##, ###) zeigen Beziehungen zwischen Abschnitten.

```
Analysiere diesen Gesch√§ftsvorschlag.

Strukturiere deine Antwort mit diesen Abschnitten:
## Zusammenfassung
## St√§rken
## Schw√§chen
## Empfehlungen
## Risikobewertung
```

<Callout type="tip" title="Abschnitte Best Practices">
Liste deine Abschnitte in der gew√ºnschten Reihenfolge auf. F√ºr Konsistenz gib an, was jeder Abschnitt enthalten soll (z.B. "Zusammenfassung: nur 2-3 S√§tze").
</Callout>

### Betonung mit Gro√übuchstaben-Direktiven

Gro√ügeschriebene W√∂rter wirken als starke Signale f√ºr das Modell und betonen kritische Einschr√§nkungen oder Anforderungen. Verwende sie sparsam f√ºr maximale Wirkung‚Äî√úbernutzung verw√§ssert ihre Effektivit√§t.

**H√§ufige Gro√übuchstaben-Direktiven:**

<InfoGrid items={[
  { label: "NIEMALS", description: "Absolutes Verbot: \"NIEMALS pers√∂nliche Meinungen einbeziehen\"", color: "red" },
  { label: "IMMER", description: "Pflichtanforderung: \"IMMER Quellen zitieren\"", color: "green" },
  { label: "WICHTIG", description: "Kritische Anweisung: \"WICHTIG: Antworten unter 100 W√∂rtern halten\"", color: "amber" },
  { label: "NICHT", description: "Starkes Verbot: \"Statistiken NICHT erfinden\"", color: "red" },
  { label: "MUSS", description: "Erforderliche Aktion: \"Ausgabe MUSS g√ºltiges JSON sein\"", color: "blue" },
  { label: "NUR", description: "Einschr√§nkung: \"Gib NUR den Code zur√ºck, keine Erkl√§rungen\"", color: "purple" },
]} />

```
Fasse diesen Artikel zusammen.

WICHTIG: Halte die Zusammenfassung unter 100 W√∂rtern.
NIEMALS Informationen hinzuf√ºgen, die nicht im Original vorhanden sind.
IMMER den urspr√ºnglichen Ton und die Perspektive beibehalten.
F√ºge NICHT deine eigenen Meinungen oder Analysen hinzu.
```

<Callout type="warning" title="Sparsam verwenden">
Wenn alles gro√ügeschrieben oder als kritisch markiert ist, sticht nichts hervor. Reserviere diese Direktiven f√ºr wirklich wichtige Einschr√§nkungen.
</Callout>

## JSON-Ausgabe

JSON (JavaScript Object Notation) ist das beliebteste Format f√ºr strukturierte KI-Ausgaben. Es ist maschinenlesbar, wird von Programmiersprachen breit unterst√ºtzt und ist perfekt f√ºr APIs, Datenbanken und Automatisierungs-Workflows. Der Schl√ºssel zu zuverl√§ssigem JSON ist ein klares Schema.

### Einfache JSON-Anfrage

Beginne mit einer Vorlage, die die genaue gew√ºnschte Struktur zeigt. F√ºge Feldnamen, Datentypen und Beispielwerte hinzu. Dies wirkt als Vertrag, dem das Modell folgen wird.

<TryIt 
  title="JSON-Extraktion"
  description="Extrahiere strukturierte Daten aus unstrukturiertem Text."
  prompt={`Extrahiere Informationen aus diesem Text und gib sie als JSON zur√ºck:

{
    "firmenname": "string",
    "gruendungsjahr": number,
    "hauptsitz": "string",
    "mitarbeiter": number,
    "branche": "string"
}

Text: "Apple Inc., gegr√ºndet 1976, hat seinen Hauptsitz in Cupertino, Kalifornien. Der Technologieriese besch√§ftigt weltweit etwa 164.000 Mitarbeiter."`}
/>

### Komplexe JSON-Strukturen

F√ºr verschachtelte Daten verwende hierarchisches JSON mit Objekten in Objekten, Arrays von Objekten und gemischten Typen. Definiere jede Ebene klar und verwende TypeScript-artige Annotationen (`"positiv" | "negativ"`) um Werte einzuschr√§nken.

```
Analysiere diese Produktbewertung und gib JSON zur√ºck:

{
  "bewertungs_id": "string (generiere eindeutig)",
  "sentiment": {
    "gesamt": "positiv" | "negativ" | "gemischt" | "neutral",
    "score": 0.0-1.0
  },
  "aspekte": [
    {
      "aspekt": "string (z.B. 'preis', 'qualit√§t')",
      "sentiment": "positiv" | "negativ" | "neutral",
      "erwahnungen": ["exakte Zitate aus der Bewertung"]
    }
  ],
  "kaufabsicht": {
    "wuerde_empfehlen": boolean,
    "konfidenz": 0.0-1.0
  },
  "schluesselphrasen": ["string-Array mit bemerkenswerten Phrasen"]
}

Gib NUR g√ºltiges JSON zur√ºck, keinen zus√§tzlichen Text.

Bewertung: "[Bewertungstext]"
```

### G√ºltiges JSON sicherstellen

Modelle f√ºgen manchmal erkl√§renden Text oder Markdown-Formatierung um JSON hinzu. Verhindere dies mit expliziten Anweisungen zum Ausgabeformat. Du kannst rohes JSON oder JSON in Code-Bl√∂cken anfordern‚Äîw√§hle basierend auf deinen Parsing-Anforderungen.

F√ºge explizite Anweisungen hinzu:

```
WICHTIG:
- Gib NUR das JSON-Objekt zur√ºck, keine Markdown-Code-Bl√∂cke
- Stelle sicher, dass alle Strings korrekt escaped sind
- Verwende null f√ºr fehlende Werte, nicht undefined
- Validiere, dass die Ausgabe parseables JSON ist
```

Oder fordere Code-Bl√∂cke an, indem du das Modell bittest, seine Ausgabe zu umschlie√üen:

````
Gib das Ergebnis als JSON-Code-Block zur√ºck:
```json
{ ... }
```
````

## YAML-Ausgabe

YAML ist menschenlesbarer als JSON und verwendet Einr√ºckung statt Klammern. Es ist der Standard f√ºr Konfigurationsdateien (Docker, Kubernetes, GitHub Actions) und funktioniert gut, wenn die Ausgabe von Menschen gelesen oder in DevOps-Kontexten verwendet wird. YAML ist einr√ºckungssensitiv, also sei spezifisch √ºber Formatierungsanforderungen.

<TryIt 
  compact
  title="YAML-Generierung"
  prompt={`Generiere einen GitHub Actions Workflow f√ºr ein Node.js-Projekt.

Gib als g√ºltiges YAML zur√ºck:
- Einbeziehen: Install, Lint, Test, Build-Stufen
- Verwende Node.js 18
- Cache npm Dependencies
- Ausf√ºhren bei Push auf main und Pull Requests`}
/>

## XML-Ausgabe

XML wird immer noch f√ºr viele Enterprise-Systeme, SOAP-APIs und Legacy-Integrationen ben√∂tigt. Es ist ausf√ºhrlicher als JSON, bietet aber Funktionen wie Attribute, Namespaces und CDATA-Abschnitte f√ºr komplexe Daten. Gib Elementnamen, Verschachtelungsstruktur und wo Attribute vs. Kind-Elemente verwendet werden sollen an.

```
Konvertiere diese Daten in XML-Format:

Anforderungen:
- Root-Element: <katalog>
- Jedes Element in <buch>-Element
- Attribute wo angemessen einbeziehen
- CDATA f√ºr Beschreibungstext verwenden

Daten: [Buchdaten]
```

## Benutzerdefinierte Formate

Manchmal passen Standardformate nicht zu deinen Anforderungen. Du kannst jedes benutzerdefinierte Format definieren, indem du eine klare Vorlage bereitstellst. Benutzerdefinierte Formate funktionieren gut f√ºr Berichte, Logs oder dom√§nenspezifische Ausgaben, die von Menschen gelesen werden.

### Strukturiertes Analyseformat

Verwende Trennzeichen (===, ---, [ABSCHNITT]) um √ºbersichtliche Dokumente mit klaren Grenzen zwischen Abschnitten zu erstellen. Dieses Format ist gro√üartig f√ºr Code-Reviews, Audits und Analysen.

```
Analysiere diesen Code mit diesem exakten Format:

=== CODE-ANALYSE ===

[ZUSAMMENFASSUNG]
Ein Absatz √úberblick

[PROBLEME]
‚Ä¢ KRITISCH: [Problem] ‚Äî [datei:zeile]
‚Ä¢ WARNUNG: [Problem] ‚Äî [datei:zeile]  
‚Ä¢ INFO: [Problem] ‚Äî [datei:zeile]

[METRIKEN]
Komplexit√§t: [Niedrig/Mittel/Hoch]
Wartbarkeit: [score]/10
Testabdeckung: [gesch√§tzt %]

[EMPFEHLUNGEN]
1. [Priorit√§t 1 Empfehlung]
2. [Priorit√§t 2 Empfehlung]

=== ENDE ANALYSE ===
```

### L√ºckentext-Format

Vorlagen mit L√ºcken (___) leiten das Modell an, spezifische Felder auszuf√ºllen und dabei exakte Formatierung beizubehalten. Dieser Ansatz ist ausgezeichnet f√ºr Formulare, Briefings und standardisierte Dokumente, bei denen Konsistenz wichtig ist.

```
Vervollst√§ndige diese Vorlage f√ºr das gegebene Produkt:

PRODUKT-BRIEF
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Name: _______________
Slogan: _______________
Zielnutzer: _______________
Gel√∂stes Problem: _______________
Hauptmerkmale:
  1. _______________
  2. _______________
  3. _______________
Alleinstellungsmerkmal: _______________

Produkt: [Produktbeschreibung]
```

## Typisierte Antworten

Typisierte Antworten definieren Kategorien oder Entit√§tstypen, die das Modell erkennen und kennzeichnen soll. Diese Technik ist essentiell f√ºr Named Entity Recognition (NER), Klassifizierungsaufgaben und jede Extraktion, bei der du Informationen konsistent kategorisieren musst. Definiere deine Typen klar mit Beispielen.

<TryIt 
  compact
  title="Entit√§ts-Extraktion"
  prompt={`Extrahiere Entit√§ten aus diesem Text.

Entit√§tstypen:
- PERSON: Vollst√§ndige Namen von Personen
- ORG: Organisations-/Firmennamen
- ORT: St√§dte, L√§nder, Adressen
- DATUM: Daten im ISO-Format (YYYY-MM-DD)
- GELD: Geldbetr√§ge mit W√§hrung

Formatiere jede als: [TYP]: [wert]

Text: "Tim Cook k√ºndigte an, dass Apple bis Dezember 2024 1 Milliarde Dollar in eine neue Austin-Anlage investieren wird."`}
/>

## Mehrteilige strukturierte Antworten

Wenn du umfassende Ausgaben ben√∂tigst, die mehrere Aspekte abdecken, definiere verschiedene Teile mit klaren Grenzen. Gib genau an, was in jeden Teil geh√∂rt‚ÄîFormat, L√§nge und Inhaltstyp. Dies verhindert, dass das Modell Abschnitte vermischt oder Teile ausl√§sst.

```
Recherchiere dieses Thema und liefere:

### TEIL 1: ZUSAMMENFASSUNG
[2-3 S√§tze √úberblick]

### TEIL 2: HAUPTERKENNTNISSE
[Genau 5 Aufz√§hlungspunkte]

### TEIL 3: DATENTABELLE
| Metrik | Wert | Quelle |
|--------|------|--------|
[Mindestens 5 Zeilen]

### TEIL 4: EMPFEHLUNGEN
[Nummerierte Liste mit 3 umsetzbaren Empfehlungen]

### TEIL 5: WEITERF√úHRENDE LEKT√úRE
[3 vorgeschlagene Ressourcen mit kurzen Beschreibungen]
```

## Bedingte Formatierung

Bedingte Formatierung erm√∂glicht es dir, verschiedene Ausgabeformate basierend auf den Eigenschaften der Eingabe zu definieren. Dies ist m√§chtig f√ºr Klassifizierung, Triage und Routing-Systeme, bei denen das Antwortformat basierend auf dem, was das Modell erkennt, variieren sollte. Verwende klare wenn/dann-Logik mit expliziten Ausgabevorlagen f√ºr jeden Fall.

<TryIt 
  compact
  title="Ticket-Klassifizierung"
  prompt={`Klassifiziere dieses Support-Ticket.

Falls DRINGEND (System ausgefallen, Sicherheitsproblem, Datenverlust):
  Antwort: üî¥ DRINGEND | [Kategorie] | [Vorgeschlagene Aktion]

Falls HOCH (betrifft mehrere Nutzer, Umsatzauswirkung):
  Antwort: üü† HOCH | [Kategorie] | [Vorgeschlagene Aktion]

Falls MITTEL (einzelner Nutzer betroffen, Workaround existiert):
  Antwort: üü° MITTEL | [Kategorie] | [Vorgeschlagene Aktion]

Falls NIEDRIG (Fragen, Feature-Anfragen):
  Antwort: üü¢ NIEDRIG | [Kategorie] | [Vorgeschlagene Aktion]

Ticket: "Ich kann mich nicht in mein Konto einloggen. Ich habe zweimal versucht mein Passwort zur√ºckzusetzen, bekomme aber immer noch einen Fehler. Das blockiert mein gesamtes Team vom Zugriff auf das Dashboard."`}
/>

## Arrays und Listen in JSON

Das Extrahieren mehrerer Elemente in Arrays erfordert sorgf√§ltige Schema-Definition. Gib die Array-Struktur an, was jedes Element enthalten soll, und wie Randf√§lle behandelt werden (leere Arrays, einzelne Elemente). Ein Z√§hlfeld hilft bei der Vollst√§ndigkeitspr√ºfung.

```
Extrahiere alle Aktionspunkte aus diesem Meeting-Transkript.

Gib als JSON-Array zur√ºck:
{
  "aktionspunkte": [
    {
      "aufgabe": "string, der die Aufgabe beschreibt",
      "zustaendig": "Personenname oder 'Nicht zugewiesen'",
      "deadline": "Datum falls genannt, sonst null",
      "prioritaet": "hoch" | "mittel" | "niedrig",
      "kontext": "relevantes Zitat aus dem Transkript"
    }
  ],
  "gesamt_anzahl": number
}

Transkript: "[Meeting-Transkript]"
```

## Validierungsanweisungen

Selbstvalidierung fordert das Modell auf, seine eigene Ausgabe vor dem Antworten zu √ºberpr√ºfen. Dies f√§ngt h√§ufige Probleme wie fehlende Abschnitte, Platzhaltertext oder Einschr√§nkungsverletzungen ab. Das Modell wird intern iterieren um Probleme zu beheben, was die Ausgabequalit√§t ohne zus√§tzliche API-Aufrufe verbessert.

```
Generiere den Bericht, dann:

VALIDIERUNGS-CHECKLISTE:
‚ñ° Alle erforderlichen Abschnitte vorhanden
‚ñ° Kein Platzhaltertext verblieben
‚ñ° Alle Statistiken mit Quellen
‚ñ° Wortanzahl innerhalb 500-700 W√∂rter
‚ñ° Fazit bezieht sich auf Einleitung zur√ºck

Falls eine Pr√ºfung fehlschl√§gt, vor dem Antworten korrigieren.
```

## Umgang mit optionalen Feldern

Reale Daten haben oft fehlende Werte. Weise das Modell explizit an, wie mit optionalen Feldern umzugehen ist‚Äî`null` zu verwenden ist sauberer als leere Strings und einfacher programmatisch zu verarbeiten. Verhindere auch "Halluzination" fehlender Daten, indem du betonst, dass das Modell niemals Informationen erfinden soll.

```
Extrahiere Kontaktinformationen. Verwende null f√ºr fehlende Felder.

{
  "name": "string (erforderlich)",
  "email": "string oder null",
  "telefon": "string oder null", 
  "firma": "string oder null",
  "rolle": "string oder null",
  "linkedin": "URL-string oder null"
}

WICHTIG: 
- Erfinde niemals Informationen, die nicht in der Quelle sind
- Verwende null, nicht leere Strings, f√ºr fehlende Daten
- Telefonnummern wenn m√∂glich im E.164-Format
```

## Zusammenfassung

<Callout type="tip" title="Schl√ºsseltechniken">
Sei explizit √ºber das Format, verwende Beispiele, gib Typen an, behandle Randf√§lle mit null-Werten, und bitte das Modell seine eigene Ausgabe zu validieren.
</Callout>

<Quiz 
  question="Was ist der Hauptvorteil von strukturierter gegen√ºber unstrukturierter Ausgabe?"
  options={[
    "Sie verwendet weniger Tokens",
    "Sie ist einfacher f√ºr die KI zu generieren",
    "Sie kann programmatisch geparst und validiert werden",
    "Sie produziert immer korrekte Informationen"
  ]}
  correctIndex={2}
  explanation="Strukturierte Ausgaben wie JSON k√∂nnen von Code geparst, √ºber Abfragen hinweg verglichen, in Workflows integriert und auf Vollst√§ndigkeit validiert werden‚ÄîDinge, die mit Freitext schwierig oder unm√∂glich sind."
/>

Strukturierte Ausgaben sind essentiell f√ºr den Aufbau zuverl√§ssiger KI-gest√ºtzter Anwendungen. Im n√§chsten Kapitel erkunden wir Chain-of-Thought-Prompting f√ºr komplexe Denkaufgaben.
