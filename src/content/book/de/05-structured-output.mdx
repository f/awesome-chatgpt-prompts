Konsistente, gut formatierte Ausgaben zu bekommen ist essenziell f√ºr Produktionsanwendungen und effiziente Workflows. Dieses Kapitel behandelt Techniken zur genauen Kontrolle, wie KI-Modelle ihre Antworten formatieren.

<Callout type="info" title="Von Prosa zu Daten">
Strukturierte Ausgabe transformiert KI-Antworten von Freitext in handlungsf√§hige, parsierbare Daten.
</Callout>

## Warum Struktur wichtig ist

<StructuredOutputDemo />

## Grundlegende Formatierungstechniken

### Listen

Listen sind perfekt f√ºr Schritt-f√ºr-Schritt-Anleitungen, Ranglisten oder Sammlungen verwandter Punkte. Sie sind leicht zu scannen und zu parsen. Verwende **nummerierte Listen**, wenn die Reihenfolge wichtig ist (Schritte, Rankings), und **Aufz√§hlungspunkte** f√ºr ungeordnete Sammlungen.

<TryIt 
  compact
  title="Listenformatierung"
  prompt={`Gib 5 Tipps f√ºr besseren Schlaf.

Format: Nummerierte Liste mit einer kurzen Erkl√§rung f√ºr jeden.
Jeder Tipp sollte fett sein, gefolgt von einem Bindestrich und Erkl√§rung.`}
/>

<Callout type="tip" title="Listen-Best-Practices">
Spezifiziere die genaue Anzahl der gew√ºnschten Elemente, ob Erkl√§rungen enthalten sein sollen und ob Elemente fett oder mit einer bestimmten Struktur sein sollen.
</Callout>

### Tabellen

Tabellen sind hervorragend zum Vergleichen mehrerer Elemente √ºber dieselben Dimensionen. Sie sind ideal f√ºr Feature-Vergleiche, Datenzusammenfassungen und alle Informationen mit konsistenten Attributen. Definiere deine Spalten√ºberschriften immer explizit.

<TryIt 
  compact
  title="Tabellenformatierung"
  prompt={`Vergleiche die Top 4 Python-Web-Frameworks.

Formatiere als Markdown-Tabelle mit Spalten:
| Framework | Am besten f√ºr | Lernkurve | Performance |`}
/>

<Callout type="tip" title="Tabellen-Best-Practices">
Spezifiziere Spaltennamen, erwartete Datentypen (Text, Zahlen, Bewertungen) und wie viele Zeilen du brauchst. F√ºr komplexe Vergleiche beschr√§nke dich auf 4-6 Spalten f√ºr Lesbarkeit.
</Callout>

### √úberschriften und Abschnitte

√úberschriften schaffen eine klare Dokumentstruktur, machen lange Antworten scannbar und organisiert. Verwende sie f√ºr Berichte, Analysen oder jede mehrteilige Antwort. Hierarchische √úberschriften (##, ###) zeigen Beziehungen zwischen Abschnitten.

```
Analysiere diesen Gesch√§ftsvorschlag.

Strukturiere deine Antwort mit diesen Abschnitten:
## Zusammenfassung
## St√§rken
## Schw√§chen
## Empfehlungen
## Risikobewertung
```

<Callout type="tip" title="Abschnitts-Best-Practices">
Liste deine Abschnitte in der gew√ºnschten Reihenfolge auf. F√ºr Konsistenz spezifiziere, was jeder Abschnitt enthalten soll (z.B. ‚ÄûZusammenfassung: nur 2-3 S√§tze").
</Callout>

### Betonung mit Gro√übuchstaben-Direktiven

Gro√übuchstaben-W√∂rter wirken als starke Signale an das Modell und betonen kritische Einschr√§nkungen oder Anforderungen. Verwende sie sparsam f√ºr maximale Wirkung ‚Äì √úbernutzung verw√§ssert ihre Effektivit√§t.

**H√§ufige Gro√übuchstaben-Direktiven:**

<InfoGrid items={[
  { label: "NIEMALS", description: "Absolutes Verbot: 'NIEMALS pers√∂nliche Meinungen einschlie√üen'", color: "red" },
  { label: "IMMER", description: "Pflichtanforderung: 'IMMER Quellen zitieren'", color: "green" },
  { label: "WICHTIG", description: "Kritische Anweisung: 'WICHTIG: Antworten unter 100 W√∂rtern halten'", color: "amber" },
  { label: "NICHT", description: "Starkes Verbot: 'Statistiken NICHT erfinden'", color: "red" },
  { label: "MUSS", description: "Erforderliche Aktion: 'Ausgabe MUSS g√ºltiges JSON sein'", color: "blue" },
  { label: "NUR", description: "Einschr√§nkung: 'NUR den Code zur√ºckgeben, keine Erkl√§rungen'", color: "purple" },
]} />

```
Fasse diesen Artikel zusammen.

WICHTIG: Halte die Zusammenfassung unter 100 W√∂rtern.
NIEMALS Informationen hinzuf√ºgen, die nicht im Original vorhanden sind.
IMMER den urspr√ºnglichen Ton und die Perspektive beibehalten.
Eigene Meinungen oder Analysen NICHT einschlie√üen.
```

<Callout type="warning" title="Sparsam verwenden">
Wenn alles gro√ügeschrieben oder als kritisch markiert ist, sticht nichts hervor. Reserviere diese Direktiven f√ºr wirklich wichtige Einschr√§nkungen.
</Callout>

## JSON-Ausgabe

JSON (JavaScript Object Notation) ist das beliebteste Format f√ºr strukturierte KI-Ausgaben. Es ist maschinenlesbar, von Programmiersprachen weit unterst√ºtzt und perfekt f√ºr APIs, Datenbanken und Automatisierungs-Workflows. Der Schl√ºssel zu zuverl√§ssigem JSON ist die Bereitstellung eines klaren Schemas.

### Grundlegende JSON-Anfrage

Beginne mit einer Vorlage, die die genaue gew√ºnschte Struktur zeigt. F√ºge Feldnamen, Datentypen und Beispielwerte hinzu. Dies fungiert als Vertrag, dem das Modell folgen wird.

<TryIt 
  title="JSON-Extraktion"
  description="Extrahiere strukturierte Daten aus unstrukturiertem Text."
  prompt={`Extrahiere Informationen aus diesem Text und gib sie als JSON zur√ºck:

{
    "company_name": "string",
    "founding_year": number,
    "headquarters": "string",
    "employees": number,
    "industry": "string"
}

Text: "Die Siemens AG, gegr√ºndet 1847, hat ihren Hauptsitz in M√ºnchen, Deutschland. Der Technologiekonzern besch√§ftigt weltweit etwa 311.000 Mitarbeiter."`}
/>

### Komplexe JSON-Strukturen

F√ºr verschachtelte Daten verwende hierarchisches JSON mit Objekten in Objekten, Arrays von Objekten und gemischten Typen. Definiere jede Ebene klar und verwende TypeScript-Stil-Annotationen (`"positive" | "negative"`), um Werte einzuschr√§nken.

```
Analysiere diese Produktbewertung und gib JSON zur√ºck:

{
  "review_id": "string (generiere eindeutig)",
  "sentiment": {
    "overall": "positive" | "negative" | "mixed" | "neutral",
    "score": 0.0-1.0
  },
  "aspects": [
    {
      "aspect": "string (z.B. 'Preis', 'Qualit√§t')",
      "sentiment": "positive" | "negative" | "neutral",
      "mentions": ["exakte Zitate aus der Bewertung"]
    }
  ],
  "purchase_intent": {
    "would_recommend": boolean,
    "confidence": 0.0-1.0
  },
  "key_phrases": ["String-Array bemerkenswerter Phrasen"]
}

Gib NUR g√ºltiges JSON zur√ºck, keinen zus√§tzlichen Text.

Bewertung: "[Bewertungstext]"
```

### G√ºltiges JSON sicherstellen

Modelle f√ºgen manchmal erkl√§renden Text oder Markdown-Formatierung um JSON hinzu. Verhindere dies mit expliziten Anweisungen zum Ausgabeformat. Du kannst rohes JSON oder JSON in Code-Bl√∂cken anfordern ‚Äì w√§hle basierend auf deinen Parsing-Bed√ºrfnissen.

F√ºge explizite Anweisungen hinzu:

```
WICHTIG:
- Gib NUR das JSON-Objekt zur√ºck, keine Markdown-Code-Bl√∂cke
- Stelle sicher, dass alle Strings korrekt escaped sind
- Verwende null f√ºr fehlende Werte, nicht undefined
- Validiere, dass die Ausgabe parsebares JSON ist
```

Oder fordere Code-Bl√∂cke an, indem du das Modell bittest, seine Ausgabe zu wrappen:

````
Gib das Ergebnis als JSON-Code-Block zur√ºck:
```json
{ ... }
```
````

## YAML-Ausgabe

YAML ist menschenlesbarer als JSON und verwendet Einr√ºckung statt Klammern. Es ist der Standard f√ºr Konfigurationsdateien (Docker, Kubernetes, GitHub Actions) und funktioniert gut, wenn die Ausgabe von Menschen gelesen oder in DevOps-Kontexten verwendet wird. YAML ist empfindlich bei Einr√ºckung, also sei spezifisch √ºber Formatierungsanforderungen.

<TryIt 
  compact
  title="YAML-Generierung"
  prompt={`Generiere einen GitHub Actions Workflow f√ºr ein Node.js-Projekt.

Gib als g√ºltiges YAML zur√ºck:
- Enth√§lt: install, lint, test, build Stufen
- Verwende Node.js 18
- Cache npm-Abh√§ngigkeiten
- Laufe bei Push zu main und Pull Requests`}
/>

## XML-Ausgabe

XML wird immer noch f√ºr viele Enterprise-Systeme, SOAP-APIs und Legacy-Integrationen ben√∂tigt. Es ist ausf√ºhrlicher als JSON, bietet aber Features wie Attribute, Namespaces und CDATA-Abschnitte f√ºr komplexe Daten. Spezifiziere Elementnamen, Verschachtelungsstruktur und wo Attribute vs. Kindelemente verwendet werden sollen.

```
Konvertiere diese Daten ins XML-Format:

Anforderungen:
- Wurzelelement: <catalog>
- Jedes Element in <book>-Element
- F√ºge Attribute ein, wo angemessen
- Verwende CDATA f√ºr Beschreibungstext

Daten: [Buchdaten]
```

## Benutzerdefinierte Formate

Manchmal passen Standardformate nicht zu deinen Bed√ºrfnissen. Du kannst jedes benutzerdefinierte Format definieren, indem du eine klare Vorlage bereitstellst. Benutzerdefinierte Formate funktionieren gut f√ºr Berichte, Logs oder dom√§nenspezifische Ausgaben, die von Menschen gelesen werden.

### Strukturiertes Analyseformat

Verwende Trennzeichen (===, ---, [ABSCHNITT]), um scannbare Dokumente mit klaren Grenzen zwischen Abschnitten zu erstellen. Dieses Format ist gro√üartig f√ºr Code-Reviews, Audits und Analysen.

```
Analysiere diesen Code mit diesem exakten Format:

=== CODE-ANALYSE ===

[ZUSAMMENFASSUNG]
Ein Absatz √úberblick

[PROBLEME]
‚Ä¢ KRITISCH: [Problem] ‚Äî [Datei:Zeile]
‚Ä¢ WARNUNG: [Problem] ‚Äî [Datei:Zeile]  
‚Ä¢ INFO: [Problem] ‚Äî [Datei:Zeile]

[METRIKEN]
Komplexit√§t: [Niedrig/Mittel/Hoch]
Wartbarkeit: [Punktzahl]/10
Testabdeckung: [gesch√§tzt %]

[EMPFEHLUNGEN]
1. [Priorit√§t 1 Empfehlung]
2. [Priorit√§t 2 Empfehlung]

=== ENDE ANALYSE ===
```

### L√ºckentext-Format

Vorlagen mit L√ºcken (___) leiten das Modell an, spezifische Felder auszuf√ºllen, w√§hrend die exakte Formatierung beibehalten wird. Dieser Ansatz ist ausgezeichnet f√ºr Formulare, Briefs und standardisierte Dokumente, bei denen Konsistenz wichtig ist.

```
Vervollst√§ndige diese Vorlage f√ºr das gegebene Produkt:

PRODUKT-BRIEF
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Name: _______________
Slogan: _______________
Zielnutzer: _______________
Gel√∂stes Problem: _______________
Schl√ºsselfeatures:
  1. _______________
  2. _______________
  3. _______________
Differenzierungsmerkmal: _______________

Produkt: [Produktbeschreibung]
```

## Typisierte Antworten

Typisierte Antworten definieren Kategorien oder Entit√§tstypen, die das Modell erkennen und beschriften soll. Diese Technik ist essenziell f√ºr Named Entity Recognition (NER), Klassifikationsaufgaben und jede Extraktion, bei der du Informationen konsistent kategorisieren musst. Definiere deine Typen klar mit Beispielen.

<TryIt 
  compact
  title="Entit√§tsextraktion"
  prompt={`Extrahiere Entit√§ten aus diesem Text.

Entit√§tstypen:
- PERSON: Vollst√§ndige Namen von Personen
- ORG: Organisations-/Firmennamen
- ORT: St√§dte, L√§nder, Adressen
- DATUM: Daten im ISO-Format (JJJJ-MM-TT)
- GELD: Geldbetr√§ge mit W√§hrung

Formatiere jeden als: [TYP]: [Wert]

Text: "Tim Cook k√ºndigte an, dass Apple bis Dezember 2024 1 Milliarde Dollar in eine neue Anlage in Austin investieren wird."`}
/>

## Mehrteilige strukturierte Antworten

Wenn du umfassende Ausgaben brauchst, die mehrere Aspekte abdecken, definiere unterschiedliche Teile mit klaren Grenzen. Spezifiziere genau, was in jeden Teil geh√∂rt ‚Äì Format, L√§nge und Inhaltstyp. Dies verhindert, dass das Modell Abschnitte vermischt oder wegl√§sst.

```
Recherchiere dieses Thema und liefere:

### TEIL 1: ZUSAMMENFASSUNG
[2-3 S√§tze √úberblick]

### TEIL 2: SCHL√úSSELERKENNTNISSE
[Genau 5 Stichpunkte]

### TEIL 3: DATENTABELLE
| Metrik | Wert | Quelle |
|--------|------|--------|
[Mindestens 5 Zeilen einschlie√üen]

### TEIL 4: EMPFEHLUNGEN
[Nummerierte Liste von 3 umsetzbaren Empfehlungen]

### TEIL 5: WEITERF√úHRENDE LEKT√úRE
[3 vorgeschlagene Ressourcen mit kurzen Beschreibungen]
```

## Bedingte Formatierung

Bedingte Formatierung erm√∂glicht dir, verschiedene Ausgabeformate basierend auf den Eigenschaften der Eingabe zu definieren. Dies ist m√§chtig f√ºr Klassifikation, Triage und Routing-Systeme, bei denen das Antwortformat je nach dem variieren sollte, was das Modell erkennt. Verwende klare wenn/dann-Logik mit expliziten Ausgabevorlagen f√ºr jeden Fall.

<TryIt 
  compact
  title="Ticket-Klassifikation"
  prompt={`Klassifiziere dieses Support-Ticket.

Wenn DRINGEND (System ausgefallen, Sicherheitsproblem, Datenverlust):
  Gib zur√ºck: üî¥ DRINGEND | [Kategorie] | [Vorgeschlagene Aktion]

Wenn HOCH (betrifft mehrere Nutzer, Umsatzauswirkung):
  Gib zur√ºck: üü† HOCH | [Kategorie] | [Vorgeschlagene Aktion]

Wenn MITTEL (einzelner Nutzer betroffen, Workaround existiert):
  Gib zur√ºck: üü° MITTEL | [Kategorie] | [Vorgeschlagene Aktion]

Wenn NIEDRIG (Fragen, Feature-Anfragen):
  Gib zur√ºck: üü¢ NIEDRIG | [Kategorie] | [Vorgeschlagene Aktion]

Ticket: "Ich kann mich nicht in mein Konto einloggen. Ich habe zweimal versucht, mein Passwort zur√ºckzusetzen, bekomme aber immer noch einen Fehler. Das blockiert mein gesamtes Team beim Zugriff auf das Dashboard."`}
/>

## Arrays und Listen in JSON

Das Extrahieren mehrerer Elemente in Arrays erfordert sorgf√§ltige Schema-Definition. Spezifiziere die Array-Struktur, was jedes Element enthalten soll und wie Randf√§lle behandelt werden (leere Arrays, einzelne Elemente). Ein Z√§hlfeld hilft, Vollst√§ndigkeit zu verifizieren.

```
Extrahiere alle Aktionspunkte aus diesem Meeting-Protokoll.

Gib als JSON-Array zur√ºck:
{
  "action_items": [
    {
      "task": "String, der die Aufgabe beschreibt",
      "assignee": "Personenname oder 'Nicht zugewiesen'",
      "deadline": "Datum wenn erw√§hnt, sonst null",
      "priority": "high" | "medium" | "low",
      "context": "relevantes Zitat aus dem Protokoll"
    }
  ],
  "total_count": number
}

Protokoll: "[Meeting-Protokoll]"
```

## Validierungsanweisungen

Selbstvalidierung fordert das Modell auf, seine eigene Ausgabe vor dem Antworten zu pr√ºfen. Dies f√§ngt h√§ufige Probleme wie fehlende Abschnitte, Platzhaltertext oder Constraint-Verletzungen ab. Das Modell wird intern iterieren, um Probleme zu beheben, was die Ausgabequalit√§t ohne zus√§tzliche API-Aufrufe verbessert.

```
Generiere den Bericht, dann:

VALIDIERUNGS-CHECKLISTE:
‚ñ° Alle erforderlichen Abschnitte vorhanden
‚ñ° Kein Platzhaltertext verbleibend
‚ñ° Alle Statistiken enthalten Quellen
‚ñ° Wortanzahl innerhalb von 500-700 W√∂rtern
‚ñ° Fazit bezieht sich zur√ºck auf Einleitung

Wenn eine Pr√ºfung fehlschl√§gt, vor dem Antworten beheben.
```

## Umgang mit optionalen Feldern

Reale Daten haben oft fehlende Werte. Weise das Modell explizit an, wie optionale Felder behandelt werden sollen ‚Äì die Verwendung von `null` ist sauberer als leere Strings und einfacher programmatisch zu verarbeiten. Verhindere auch ‚ÄûHalluzination" fehlender Daten, indem du betonst, dass das Modell niemals Informationen erfinden soll.

```
Extrahiere Kontaktinformationen. Verwende null f√ºr fehlende Felder.

{
  "name": "string (erforderlich)",
  "email": "string oder null",
  "phone": "string oder null", 
  "company": "string oder null",
  "role": "string oder null",
  "linkedin": "URL-String oder null"
}

WICHTIG: 
- Niemals Informationen erfinden, die nicht in der Quelle sind
- Verwende null, nicht leere Strings, f√ºr fehlende Daten
- Telefonnummern im E.164-Format wenn m√∂glich
```

## Zusammenfassung

<Callout type="tip" title="Schl√ºsseltechniken">
Sei explizit √ºber das Format, verwende Beispiele, spezifiziere Typen, behandle Randf√§lle mit null-Werten und bitte das Modell, seine eigene Ausgabe zu validieren.
</Callout>

<Quiz 
  question="Was ist der Hauptvorteil strukturierter Ausgabe gegen√ºber unstrukturiertem Text?"
  options={[
    "Es verwendet weniger Tokens",
    "Es ist einfacher f√ºr die KI zu generieren",
    "Es kann programmatisch geparst und validiert werden",
    "Es produziert immer korrekte Informationen"
  ]}
  correctIndex={2}
  explanation="Strukturierte Ausgaben wie JSON k√∂nnen von Code geparst, √ºber Abfragen hinweg verglichen, in Workflows integriert und auf Vollst√§ndigkeit validiert werden ‚Äì Dinge, die mit Freitext schwierig oder unm√∂glich sind."
/>

Strukturierte Ausgaben sind essenziell f√ºr den Aufbau zuverl√§ssiger KI-gest√ºtzter Anwendungen. Im n√§chsten Kapitel werden wir Chain-of-Thought-Prompting f√ºr komplexe Denkaufgaben erkunden.
