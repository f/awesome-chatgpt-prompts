Prompt Engineering ist selten ein Ein-Schuss-Prozess. Die besten Prompts entstehen durch Iteration—testen, beobachten und verfeinern, bis du die gewünschten Ergebnisse erzielst.

<Callout type="info" title="Erster Entwurf, nicht Endversion">
Denke an deinen ersten Prompt als Rohentwurf. Selbst erfahrene Prompt Engineers treffen selten beim ersten Versuch ins Schwarze.
</Callout>

## Der Iterationszyklus

Effektive Prompt-Verfeinerung folgt einem vorhersehbaren Zyklus: schreiben, testen, analysieren und verbessern. Jede Iteration bringt dich näher zu einem Prompt, der zuverlässig die Ergebnisse produziert, die du brauchst.

<IterativeRefinementDemo />

## Häufige Verfeinerungsmuster

Die meisten Prompt-Fehler fallen in eine Handvoll Kategorien. Diese Muster erkennen zu lernen ermöglicht es dir, Probleme schnell zu diagnostizieren und zu beheben, ohne von vorne anzufangen.

### Problem: Ausgabe zu lang

Eines der häufigsten Probleme. Ohne explizite Einschränkungen tendieren Modelle dazu, gründlich statt prägnant zu sein.

<DiffView 
  before="Erkläre, wie Photosynthese funktioniert."
  after={`Erkläre, wie Photosynthese funktioniert, in 3-4 Sätzen, die für ein 10-jähriges Kind geeignet sind.`}
  beforeLabel="Original"
  afterLabel="Verfeinert"
/>

### Problem: Ausgabe zu vage

Vage Prompts produzieren vage Ausgaben. Das Modell kann nicht deine Gedanken lesen, was "besser" bedeutet oder welche Aspekte dir am wichtigsten sind.

<DiffView 
  before="Gib mir Tipps für bessere Präsentationen."
  after={`Gib mir 5 spezifische, umsetzbare Tipps zur Verbesserung technischer Präsentationen für nicht-technische Stakeholder. Füge für jeden Tipp ein konkretes Beispiel hinzu.`}
  beforeLabel="Original"
  afterLabel="Verfeinert"
/>

### Problem: Falscher Ton

Ton ist subjektiv und variiert je nach Kontext. Was für das Modell "professionell" klingt, entspricht möglicherweise nicht der Stimme deiner Organisation oder der Beziehung zu deinem Empfänger.

<DiffView 
  before="Schreibe eine Entschuldigungs-E-Mail für das Verpassen einer Deadline."
  after={`Schreibe eine professionelle aber herzliche Entschuldigungs-E-Mail für das Verpassen einer Projekt-Deadline. Der Ton sollte verantwortungsbewusst sein, ohne übermäßig apologetisch zu wirken. Füge einen konkreten Plan zur Vermeidung zukünftiger Verzögerungen hinzu.`}
  beforeLabel="Original"
  afterLabel="Verfeinert"
/>

### Problem: Fehlende Schlüsselinformationen

Offene Anfragen bekommen offene Antworten. Wenn du bestimmte Arten von Feedback brauchst, musst du explizit danach fragen.

<DiffView 
  before="Überprüfe diesen Code."
  after={`Überprüfe diesen Python-Code auf:
1. Bugs und logische Fehler
2. Performance-Probleme
3. Sicherheitslücken
4. Code-Stil (PEP 8)

Erkläre für jedes gefundene Problem das Problem und schlage eine Lösung vor.

[code]`}
  beforeLabel="Original"
  afterLabel="Verfeinert"
/>

### Problem: Inkonsistentes Format

Ohne Vorlage wird das Modell jede Antwort anders strukturieren, was Vergleiche erschwert und Automatisierung unmöglich macht.

<DiffView 
  before="Analysiere diese drei Produkte."
  after={`Analysiere diese drei Produkte mit diesem exakten Format für jedes:

## [Produktname]
**Preis:** X€
**Vorteile:** [Aufzählungsliste]
**Nachteile:** [Aufzählungsliste]
**Beste Für:** [ein Satz]
**Bewertung:** X/10

[produkte]`}
  beforeLabel="Original"
  afterLabel="Verfeinert"
/>

## Systematischer Verfeinerungsansatz

Zufällige Änderungen verschwenden Zeit. Ein systematischer Ansatz hilft dir, Probleme schnell zu identifizieren und effizient zu beheben.

### Schritt 1: Das Problem diagnostizieren

Bevor du etwas änderst, identifiziere, was tatsächlich falsch ist. Verwende diese Diagnosetabelle, um Symptome auf Lösungen abzubilden:

<div className="my-4 grid gap-2">
  <div className="grid grid-cols-3 gap-2 p-3 bg-muted/50 rounded-lg text-sm">
    <span className="font-semibold">Symptom</span>
    <span className="font-semibold">Wahrscheinliche Ursache</span>
    <span className="font-semibold">Lösung</span>
  </div>
  <div className="grid grid-cols-3 gap-2 p-3 bg-red-50 dark:bg-red-950/20 rounded-lg text-sm">
    <span>Zu lang</span>
    <span className="text-muted-foreground">Keine Längenbeschränkung</span>
    <span className="text-green-600 dark:text-green-400">Wort-/Satzlimits hinzufügen</span>
  </div>
  <div className="grid grid-cols-3 gap-2 p-3 bg-red-50 dark:bg-red-950/20 rounded-lg text-sm">
    <span>Zu kurz</span>
    <span className="text-muted-foreground">Fehlende Detailanfrage</span>
    <span className="text-green-600 dark:text-green-400">Um Ausführung bitten</span>
  </div>
  <div className="grid grid-cols-3 gap-2 p-3 bg-red-50 dark:bg-red-950/20 rounded-lg text-sm">
    <span>Themenfremd</span>
    <span className="text-muted-foreground">Vage Anweisungen</span>
    <span className="text-green-600 dark:text-green-400">Spezifischer sein</span>
  </div>
  <div className="grid grid-cols-3 gap-2 p-3 bg-red-50 dark:bg-red-950/20 rounded-lg text-sm">
    <span>Falsches Format</span>
    <span className="text-muted-foreground">Format nicht spezifiziert</span>
    <span className="text-green-600 dark:text-green-400">Exakte Struktur definieren</span>
  </div>
  <div className="grid grid-cols-3 gap-2 p-3 bg-red-50 dark:bg-red-950/20 rounded-lg text-sm">
    <span>Falscher Ton</span>
    <span className="text-muted-foreground">Publikum nicht klar</span>
    <span className="text-green-600 dark:text-green-400">Publikum/Stil spezifizieren</span>
  </div>
  <div className="grid grid-cols-3 gap-2 p-3 bg-red-50 dark:bg-red-950/20 rounded-lg text-sm">
    <span>Inkonsistent</span>
    <span className="text-muted-foreground">Keine Beispiele bereitgestellt</span>
    <span className="text-green-600 dark:text-green-400">Few-Shot-Beispiele hinzufügen</span>
  </div>
</div>

### Schritt 2: Gezielte Änderungen vornehmen

Widerstehe dem Drang, alles neu zu schreiben. Mehrere Variablen gleichzeitig zu ändern macht es unmöglich zu wissen, was geholfen hat und was geschadet hat. Mache eine Änderung, teste sie, dann fahre fort:

```
Iteration 1: Längenbeschränkung hinzufügen
Iteration 2: Format spezifizieren
Iteration 3: Beispiel hinzufügen
Iteration 4: Tonanweisungen verfeinern
```

### Schritt 3: Dokumentiere, was funktioniert

Prompt-Engineering-Wissen geht leicht verloren. Führe ein Protokoll darüber, was du versucht hast und warum. Das spart Zeit, wenn du den Prompt später erneut besuchst oder ähnliche Herausforderungen hast:

```markdown
## Prompt: Kunden-E-Mail-Antwort

### Version 1 (zu formal)
"Schreibe eine Antwort auf diese Kundenbeschwerde."

### Version 2 (besserer Ton, fehlt noch Struktur)
"Schreibe eine freundliche aber professionelle Antwort auf diese Beschwerde. 
Zeige zuerst Empathie."

### Version 3 (final - gute Ergebnisse)
"Schreibe eine Antwort auf diese Kundenbeschwerde. Struktur:
1. Frustation anerkennen (1 Satz)
2. Spezifisch entschuldigen (1 Satz)  
3. Lösung erklären (2-3 Sätze)
4. Zusätzliche Hilfe anbieten (1 Satz)

Ton: Freundlich, professionell, empathisch aber nicht unterwürfig."
```

## Praxisbeispiel einer Iteration

Lass uns einen kompletten Iterationszyklus durchgehen, um zu sehen, wie jede Verfeinerung auf der vorherigen aufbaut. Beachte, wie jede Version spezifische Mängel der vorherigen adressiert.

### Aufgabe: Produktnamen generieren

<VersionDiff versions={[
  {
    label: "Version 1",
    content: "Generiere Namen für eine neue Produktivitäts-App.",
    note: "Zu generisch, kein Kontext"
  },
  {
    label: "Version 2",
    content: `Generiere Namen für eine neue Produktivitäts-App. Die App nutzt KI, um deine Aufgaben automatisch basierend auf Energieniveau und Kalenderverfügbarkeit zu planen.`,
    note: "Kontext hinzugefügt, immer noch generisch"
  },
  {
    label: "Version 3",
    content: `Generiere 10 einzigartige, einprägsame Namen für eine Produktivitäts-App mit diesen Eigenschaften:
- Nutzt KI zum Planen von Aufgaben basierend auf Energieniveau
- Zielgruppe: beschäftigte Berufstätige im Alter von 25-40
- Markenton: modern, intelligent, leicht verspielt
- Vermeiden: generische Wörter wie "pro", "smart", "AI", "task"

Erkläre für jeden Namen, warum er funktioniert.`,
    note: "Einschränkungen und Begründung hinzugefügt"
  },
  {
    label: "Version 4 (final)",
    content: `Generiere 10 einzigartige, einprägsame Namen für eine Produktivitäts-App.

Kontext:
- Nutzt KI zum Planen von Aufgaben basierend auf Energieniveau
- Ziel: beschäftigte Berufstätige, 25-40
- Ton: modern, intelligent, leicht verspielt

Anforderungen:
- Maximal 2-3 Silben
- Leicht zu buchstabieren und auszusprechen
- Als .com-Domain verfügbar (plausibel prüfen)
- Vermeiden: generische Wörter (pro, smart, AI, task, flow)

Format:
Name | Aussprache | Warum es funktioniert | Domain-Verfügbarkeitsschätzung`,
    note: "Strukturiertes Format, spezifische Anforderungen"
  }
]} />

## Verfeinerungsstrategien nach Aufgabentyp

Verschiedene Aufgaben scheitern auf vorhersehbare Weise. Die häufigen Fehlermodi zu kennen hilft dir, Probleme schneller zu diagnostizieren und zu beheben.

### Für Content-Generierung

Content-Generierung produziert oft generische, ziellose oder schlecht formatierte Ausgaben. Die Lösung beinhaltet meist, spezifischer über Einschränkungen zu sein, konkrete Beispiele zu liefern oder deine Markenstimme explizit zu definieren.

<InfoGrid items={[
  { icon: "target", title: "Zu generisch", description: "Spezifische Einschränkungen und Kontext hinzufügen", example: "\"Schreibe über Hunde\" → \"Schreibe über Golden Retriever für Erstbesitzer, mit Fokus auf Training und Bewegungsbedürfnisse\"" },
  { icon: "scissors", title: "Zu lang", description: "Wort-/Absatzlimits setzen", example: "Hinzufügen: \"Halte die Antwort unter 150 Wörtern\" oder \"Maximal 3 Absätze\"" },
  { icon: "palette", title: "Falscher Stil", description: "Stilbeispiele bereitstellen", example: "\"Schreibe im Stil dieses Beispiels: [Beispieltext einfügen]\"" },
  { icon: "megaphone", title: "Markenfremd", description: "Markenstimmen-Richtlinien einbeziehen", example: "\"Verwende freundlichen, lockeren Ton. Vermeide Fachjargon. Sprich den Leser mit 'du' an.\"" }
]} />

### Für Code-Generierung

Code-Ausgabe kann technisch (Syntaxfehler, falsche Sprachfeatures) oder architektonisch (schlechte Muster, fehlende Fälle) scheitern. Technische Probleme brauchen Versions-/Umgebungsspezifika; architektonische Probleme brauchen Design-Anleitung.

<InfoGrid items={[
  { icon: "code", title: "Syntaxfehler", description: "Sprachversion spezifizieren", example: "\"Verwende Python 3.11+ Syntax mit Type Hints\" oder \"ES2022 JavaScript\"" },
  { icon: "git-branch", title: "Falscher Ansatz", description: "Bevorzugte Muster beschreiben", example: "\"Verwende funktionalen Ansatz, vermeide Klassen\" oder \"Folge Repository-Muster\"" },
  { icon: "shield", title: "Fehlende Grenzfälle", description: "Zu behandelnde Szenarien auflisten", example: "\"Handle: leere Eingabe, Null-Werte, Netzwerk-Timeouts, ungültige Formate\"" },
  { icon: "tag", title: "Schlechte Benennung", description: "Namenskonventionen einbeziehen", example: "\"Verwende camelCase für Variablen, PascalCase für Klassen, UPPER_SNAKE für Konstanten\"" }
]} />

### Für Analyse

Analyseaufgaben produzieren oft oberflächliche oder unstrukturierte Ergebnisse. Leite das Modell mit spezifischen Frameworks (SWOT, Porters Five Forces), fordere mehrere Perspektiven an oder stelle eine Vorlage für die Ausgabestruktur bereit.

<InfoGrid items={[
  { icon: "layers", title: "Zu oberflächlich", description: "Nach spezifischen Frameworks fragen", example: "\"Analysiere mit SWOT-Framework\" oder \"Wende Porters Five Forces an\"" },
  { icon: "scale", title: "Einseitig", description: "Mehrere Perspektiven anfordern", example: "\"Präsentiere Argumente dafür und dagegen\" oder \"Beziehe skeptische Sichtweise ein\"" },
  { icon: "database", title: "Fehlende Daten", description: "Spezifizieren, was zu analysieren ist", example: "\"Fokus auf: Marktgröße, Wachstumsrate, Schlüsselakteure, Eintrittsbarrieren\"" },
  { icon: "layout", title: "Unstrukturiert", description: "Analysevorlage bereitstellen", example: "\"Format als: Zusammenfassung → Haupterkenntnisse → Implikationen → Empfehlungen\"" }
]} />

### Für Q&A

Frage-Antwort kann zu knapp oder zu ausführlich sein und Konfidenzindikatoren oder Quellen vermissen lassen. Spezifiziere den Detailgrad, den du brauchst, und ob du Zitate oder ausgedrückte Unsicherheit willst.

<InfoGrid items={[
  { icon: "plus", title: "Zu kurz", description: "Um Ausführung bitten", example: "\"Erkläre detailliert mit Beispielen\" oder \"Führe jeden Punkt aus\"" },
  { icon: "minus", title: "Zu lang", description: "Prägnante Antwort anfordern", example: "\"Antworte in 2-3 Sätzen\" oder \"Gib mir das TL;DR\"" },
  { icon: "help-circle", title: "Unsicher", description: "Nach Konfidenzniveau fragen", example: "\"Bewerte deine Konfidenz 1-10\" oder \"Notiere gemachte Annahmen\"" },
  { icon: "link", title: "Ohne Quellen", description: "Zitate anfordern", example: "\"Zitiere Quellen für Behauptungen\" oder \"Füge Referenzen wo möglich hinzu\"" }
]} />

## Die Feedback-Schleife-Technik

Hier ist eine Meta-Technik: Nutze das Modell selbst, um deine Prompts zu verbessern. Teile, was du versucht hast, was du bekommen hast, und was du wolltest. Das Modell kann oft Verbesserungen vorschlagen, an die du nicht gedacht hattest.

```
Ich habe diesen Prompt verwendet:
"[dein prompt]"

Und diese Ausgabe bekommen:
"[modell-ausgabe]"

Ich wollte etwas mehr [Lücke beschreiben]. Wie sollte ich 
meinen Prompt modifizieren, um bessere Ergebnisse zu bekommen?
```

## A/B-Tests für Prompts

Für Prompts, die wiederholt oder in großem Maßstab verwendet werden, nimm nicht einfach den ersten, der funktioniert. Teste Variationen, um den zuverlässigsten und qualitativ hochwertigsten Ansatz zu finden.

```
Prompt A: "Fasse diesen Artikel in 3 Stichpunkten zusammen."
Prompt B: "Extrahiere die 3 wichtigsten Erkenntnisse aus diesem Artikel."
Prompt C: "Was sind die Haupterkenntnisse aus diesem Artikel? Liste 3 auf."
```

Führe jeden mehrmals aus, vergleiche:
- Konsistenz der Ausgabe
- Qualität der Information
- Relevanz für deine Bedürfnisse

## Wann aufhören zu iterieren

Perfektion ist der Feind von gut genug. Wisse, wann dein Prompt bereit für den Einsatz ist und wann du nur für abnehmende Erträge polierst.

<div className="my-6 grid md:grid-cols-2 gap-4">
  <div className="border rounded-lg bg-green-50/50 dark:bg-green-950/20 border-green-200 dark:border-green-900">
    <p className="text-sm font-semibold text-green-700 dark:text-green-400 px-4 pt-3 flex items-center gap-2 m-0!"><IconCheck className="h-4 w-4" /> Bereit zum Versenden</p>
    <div className="text-sm p-4 pt-2 space-y-1">
      <p className="m-0!">Ausgabe erfüllt Anforderungen konsistent</p>
      <p className="m-0!">Grenzfälle werden angemessen behandelt</p>
      <p className="m-0!">Format ist zuverlässig und parsbar</p>
      <p className="m-0!">Weitere Verbesserungen zeigen abnehmende Erträge</p>
    </div>
  </div>
  <div className="border rounded-lg bg-red-50/50 dark:bg-red-950/20 border-red-200 dark:border-red-900">
    <p className="text-sm font-semibold text-red-700 dark:text-red-400 px-4 pt-3 flex items-center gap-2 m-0!"><IconX className="h-4 w-4" /> Weiter iterieren</p>
    <div className="text-sm p-4 pt-2 space-y-1">
      <p className="m-0!">Ausgabe ist inkonsistent über Durchläufe</p>
      <p className="m-0!">Grenzfälle verursachen Fehler</p>
      <p className="m-0!">Kritische Anforderungen werden verfehlt</p>
      <p className="m-0!">Du hast nicht genug Variationen getestet</p>
    </div>
  </div>
</div>

## Versionskontrolle für Prompts

Prompts sind Code. Behandle jeden Prompt, der in Produktion verwendet wird, mit der gleichen Strenge: Versionskontrolle, Changelogs und die Möglichkeit zum Rollback, wenn etwas kaputt geht.

<Callout type="tip" title="Eingebaute Versionierung">
prompts.chat enthält automatischen Versionsverlauf für deine Prompts. Jede Bearbeitung wird gespeichert, sodass du Versionen vergleichen und vorherige Iterationen mit einem Klick wiederherstellen kannst.
</Callout>

Für selbst verwaltete Prompts verwende eine Ordnerstruktur:

```
prompts/
├── kunden-antwort/
│   ├── v1.0.txt    # Erste Version
│   ├── v1.1.txt    # Tonproblem behoben
│   ├── v2.0.txt    # Große Umstrukturierung
│   └── current.txt # Symlink zur aktiven Version
└── changelog.md    # Änderungen dokumentieren
```

## Zusammenfassung

<Callout type="tip" title="Wichtige Erkenntnisse">
Fange einfach an, beobachte sorgfältig, ändere eine Sache nach der anderen, dokumentiere was funktioniert, und wisse wann aufzuhören. Die besten Prompts werden nicht geschrieben—sie werden durch systematische Iteration entdeckt.
</Callout>

<Quiz 
  question="Was ist der beste Ansatz beim Verfeinern eines Prompts, der falsche Ergebnisse produziert?"
  options={[
    "Den gesamten Prompt von Grund auf neu schreiben",
    "Mehr Beispiele hinzufügen, bis es funktioniert",
    "Eine Sache nach der anderen ändern und jede Änderung testen",
    "Den Prompt so lang wie möglich machen"
  ]}
  correctIndex={2}
  explanation="Eine Sache nach der anderen zu ändern ermöglicht es dir zu isolieren, was funktioniert und was nicht. Wenn du mehrere Dinge gleichzeitig änderst, weißt du nicht, welche Änderung das Problem behoben hat oder welche es verschlimmert hat."
/>

## Übung: Verbessere diesen Prompt

Versuche selbst, diesen schwachen Prompt zu verbessern. Bearbeite ihn, dann verwende KI um deine Version mit dem Original zu vergleichen:

<BeforeAfterEditor
  title="Verfeinere diesen E-Mail-Prompt"
  badPrompt="Schreibe eine E-Mail."
  idealPrompt={`Du bist ein professioneller Geschäftsschreiber.

Aufgabe: Schreibe eine Follow-up-E-Mail an einen potenziellen Kunden nach einem Verkaufsgespräch.

Kontext:
- Treffen mit Sarah Chen, VP Marketing bei TechCorp
- Unsere Analytics-Plattform besprochen
- Sie zeigte Interesse an den Reporting-Funktionen
- Treffen war gestern

Anforderungen:
- Professioneller aber herzlicher Ton
- Bezug auf spezifische Punkte aus unserem Treffen
- Klaren nächsten Schritt einbeziehen (Demo vereinbaren)
- Unter 150 Wörter halten

Format: Betreffzeile + E-Mail-Text`}
  task="Verwandle diesen vagen E-Mail-Prompt in etwas, das ein professionelles, effektives Ergebnis produziert."
/>

Im nächsten Kapitel erkunden wir JSON- und YAML-Prompting für strukturierte Datenanwendungen.
