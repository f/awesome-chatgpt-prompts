Понимание контекста необходимо для создания AI-приложений, которые действительно работают. В этой главе рассматривается всё, что вам нужно знать о предоставлении AI правильной информации в нужное время.

<Callout type="info" title="Почему контекст важен">
AI-модели не имеют состояния. Они не помнят прошлые разговоры. Каждый раз, когда вы отправляете сообщение, вам нужно включить всё, что AI должен знать. Это называется «контекстная инженерия».
</Callout>

## Что такое контекст?

Контекст — это вся информация, которую вы передаёте AI вместе с вашим вопросом. Представьте это так:

<Compare 
  before={{ label: "Без контекста", content: "Какой статус?" }}
  after={{ label: "С контекстом", content: "Вы — ассистент проектного менеджера. Пользователь работает над Проектом Альфа, срок сдачи которого — пятница. Последнее обновление было: 'Бэкенд завершён, фронтенд готов на 80%.'\n\nПользователь: Какой статус?" }}
/>

Без контекста AI не имеет понятия, о каком «статусе» вы спрашиваете. С контекстом он может дать полезный ответ.

### Контекстное окно

Помните из предыдущих глав: у AI есть ограниченное «контекстное окно» — максимальный объём текста, который он может видеть одновременно. Это включает:

<InfoGrid items={[
  { label: "Системный промпт", description: "Инструкции, определяющие поведение AI", color: "purple" },
  { label: "История разговора", description: "Предыдущие сообщения в этом чате", color: "blue" },
  { label: "Полученная информация", description: "Документы, данные или знания, извлечённые для этого запроса", color: "green" },
  { label: "Текущий запрос", description: "Фактический вопрос пользователя", color: "amber" },
  { label: "Ответ AI", description: "Ответ (тоже учитывается в лимите!)", color: "rose" },
]} />

## AI не имеет состояния

<Callout type="warning" title="Важная концепция">
AI ничего не помнит между разговорами. Каждый API-вызов начинается с чистого листа. Если вы хотите, чтобы AI что-то «помнил», ВЫ должны включать это в контекст каждый раз.
</Callout>

Вот почему чат-боты отправляют всю историю разговора с каждым сообщением. Дело не в том, что AI помнит — дело в том, что приложение пересылает всё заново.

<TryIt compact prompt={`Представьте, что это новый разговор без истории.

О чём я только что вас спрашивал?`} />

AI скажет, что не знает, потому что у него действительно нет доступа к какому-либо предыдущему контексту.

## RAG: Retrieval-Augmented Generation

RAG — это техника предоставления AI доступа к знаниям, на которых он не обучался. Вместо того чтобы пытаться вместить всё в обучение AI, вы:

1. **Сохраняете** свои документы в базе данных с возможностью поиска
2. **Ищете** релевантные документы, когда пользователь задаёт вопрос
3. **Извлекаете** наиболее подходящие фрагменты
4. **Дополняете** свой промпт этими фрагментами
5. **Генерируете** ответ, используя этот контекст

<div className="my-6 p-4 border rounded-lg bg-muted/30">
  <p className="font-semibold mb-3">Как работает RAG:</p>
  <div className="flex flex-col gap-2 text-sm">
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-blue-600 font-bold">1</span>
      <span>Пользователь спрашивает: «Какова наша политика возврата?»</span>
    </div>
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-blue-600 font-bold">2</span>
      <span>Система ищет в ваших документах «политику возврата»</span>
    </div>
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-blue-600 font-bold">3</span>
      <span>Находит соответствующий раздел в документе с политикой</span>
    </div>
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center text-blue-600 font-bold">4</span>
      <span>Отправляет AI: «На основе этой политики: [текст], ответьте: Какова наша политика возврата?»</span>
    </div>
    <div className="flex items-center gap-3">
      <span className="w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 flex items-center justify-center text-green-600 font-bold">5</span>
      <span>AI генерирует точный ответ, используя вашу реальную политику</span>
    </div>
  </div>
</div>

### Почему RAG?

<div className="my-6 grid md:grid-cols-2 gap-4">
  <div className="p-4 border rounded-lg">
    <p className="font-semibold text-green-600 dark:text-green-400 mb-2 flex items-center gap-2"><IconCheck className="text-green-600" /> Преимущества RAG</p>
    <ul className="text-sm space-y-1 text-muted-foreground">
      <li>Использует ваши актуальные данные</li>
      <li>Уменьшает галлюцинации</li>
      <li>Может указывать источники</li>
      <li>Легко обновлять (просто обновите документы)</li>
      <li>Не требует дорогостоящего дообучения</li>
    </ul>
  </div>
  <div className="p-4 border rounded-lg">
    <p className="font-semibold text-amber-600 dark:text-amber-400 mb-2 flex items-center gap-2"><IconLightbulb className="text-amber-600" /> Когда использовать RAG</p>
    <ul className="text-sm space-y-1 text-muted-foreground">
      <li>Боты поддержки клиентов</li>
      <li>Поиск по документации</li>
      <li>Внутренние базы знаний</li>
      <li>Любые доменно-специфичные вопросы и ответы</li>
      <li>Когда важна точность</li>
    </ul>
  </div>
</div>

## Embeddings: как работает поиск

Как RAG узнаёт, какие документы «релевантны»? Он использует **embeddings** — способ преобразования текста в числа, которые отражают смысл.

### Что такое Embeddings?

Embedding — это список чисел (вектор), который представляет смысл текста. Похожие смыслы = похожие числа.

<EmbeddingsDemo />

### Семантический поиск

С embeddings вы можете искать по смыслу, а не только по ключевым словам:

<Compare 
  before={{ label: "Поиск по ключевым словам", content: "Запрос: 'политика возврата'\nНаходит: Документы, содержащие 'политика' и 'возврат'\nПропускает: 'Как получить компенсацию'" }}
  after={{ label: "Семантический поиск", content: "Запрос: 'политика возврата'\nНаходит: Все связанные документы, включая:\n- 'Правила возмещения'\n- 'Как отправить товар обратно'\n- 'Гарантия возврата денег'" }}
/>

Вот почему RAG так эффективен — он находит релевантную информацию, даже когда точные слова не совпадают.

## Function Calling / Tool Use

Function calling позволяет AI использовать внешние инструменты — например, поиск в интернете, проверку базы данных или вызов API.

<Callout type="tip" title="Также называется">
Разные провайдеры AI называют это по-разному: «function calling» (OpenAI), «tool use» (Anthropic/Claude) или «tools» (общий термин). Все они означают одно и то же.
</Callout>

### Как это работает

1. Вы сообщаете AI, какие инструменты доступны
2. AI решает, нужен ли инструмент для ответа
3. AI выводит структурированный запрос к инструменту
4. Ваш код запускает инструмент и возвращает результаты
5. AI использует результаты для формирования ответа

<TryIt 
  title="Пример Function Calling"
  description="Этот промпт показывает, как AI решает использовать инструмент:"
  prompt={`У вас есть доступ к этим инструментам:

1. get_weather(city: string) - Получить текущую погоду для города
2. search_web(query: string) - Искать в интернете
3. calculate(expression: string) - Выполнить математические вычисления

Пользователь: Какая сейчас погода в Токио?

Подумайте пошагово: Нужен ли вам инструмент? Какой? С какими параметрами?`}
/>

## Суммаризация: управление длинными разговорами

По мере того как разговоры становятся длиннее, вы достигаете предела контекстного окна. Поскольку AI не имеет состояния (он ничего не помнит), длинные разговоры могут переполниться. Решение? **Суммаризация**.

### Проблема

<Compare 
  before={{ label: "Без суммаризации", content: "Сообщение 1 (500 токенов)\nСообщение 2 (800 токенов)\nСообщение 3 (600 токенов)\n... ещё 50 сообщений ...\n────────────────────\n= 40,000+ токенов\n= ПРЕВЫШЕН ЛИМИТ!" }}
  after={{ label: "С суммаризацией", content: "[Краткое содержание]: 200 токенов\nНедавние сообщения: 2,000 токенов\nТекущий запрос: 100 токенов\n────────────────────\n= 2,300 токенов\n= Идеально помещается!" }}
/>

### Стратегии суммаризации

Разные подходы работают для разных случаев использования. Нажмите на каждую стратегию, чтобы увидеть, как она обрабатывает один и тот же разговор:

<SummarizationDemo />

### Что фиксировать в кратком содержании

Хорошее краткое содержание разговора сохраняет то, что важно:

<Checklist 
  title="Чек-лист краткого содержания"
  items={[
    { text: "Принятые ключевые решения" },
    { text: "Упомянутые важные факты" },
    { text: "Выявленные предпочтения пользователя" },
    { text: "Текущая задача или цель" },
    { text: "Любые нерешённые вопросы" },
    { text: "Тон и уровень формальности" }
  ]}
/>

### Попробуйте: создайте краткое содержание

<TryIt 
  title="Суммаризатор разговоров"
  description="Потренируйтесь создавать краткое содержание, сохраняющее контекст, из этого разговора:"
  prompt={`Составьте краткое содержание этого разговора для управления контекстом. Краткое содержание заменит полный разговор в памяти AI.

РАЗГОВОР:
Пользователь: Привет, я изучаю Python для анализа данных
Ассистент: Добро пожаловать! Python отлично подходит для анализа данных. Какой у вас текущий уровень?
Пользователь: Я знаю базовый Excel. Полный новичок в программировании.
Ассистент: Отличная отправная точка! Начнём с переменных — они похожи на ячейки Excel, которые хранят данные.
Пользователь: Можете объяснить переменные?
Ассистент: Переменные — это контейнеры для хранения данных. В Python: name = "Alice" или age = 25
Пользователь: А что насчёт списков? Мне нужно работать с несколькими значениями.
Ассистент: Списки похожи на столбцы Excel! Создайте список так: prices = [10, 20, 30]. Доступ к элементам: prices[0].
Пользователь: Можно ли делать вычисления со списками?
Ассистент: Да! Используйте sum(prices), len(prices) или max(prices). Для сложного анализа мы позже будем использовать pandas.
Пользователь: Что такое pandas?
Ассистент: Pandas — это библиотека для анализа данных — думайте об этом как об «Excel на стероидах». В ней есть DataFrame (как таблицы).

СОЗДАЙТЕ КРАТКОЕ СОДЕРЖАНИЕ, которое фиксирует:
1. Цель и бэкграунд пользователя (1 предложение)
2. Рассмотренные темы (1 предложение)
3. Стиль обучения/предпочтения пользователя (1 предложение)
4. Что рассмотреть дальше (1 предложение)`}
/>

### Когда суммаризировать

<TryIt compact prompt={`Вы управляете контекстным окном разговора. Учитывая эти условия, решите, когда запускать суммаризацию:

КОНТЕКСТНОЕ ОКНО: максимум 8,000 токенов
ТЕКУЩЕЕ ИСПОЛЬЗОВАНИЕ:
- Системный промпт: 500 токенов
- История разговора: 6,200 токенов
- Резерв для ответа: 1,500 токенов

ПРАВИЛА:
- Суммаризировать, когда история превышает 70% доступного пространства
- Сохранять последние 5 сообщений нетронутыми
- Сохранять все предпочтения и решения пользователя

Нужно ли суммаризировать сейчас? Если да, какие сообщения следует суммаризировать, а какие оставить нетронутыми?`} />

## MCP: Model Context Protocol

MCP (Model Context Protocol) — это стандартный способ подключения AI к внешним данным и инструментам. Вместо создания отдельных интеграций для каждого провайдера AI, MCP предоставляет универсальный интерфейс.

### Почему MCP?

<InfoGrid columns={2} items={[
  { label: "Без MCP", description: "Создавать отдельные интеграции для ChatGPT, Claude, Gemini... Поддерживать несколько кодовых баз. Всё ломается при изменении API.", color: "red" },
  { label: "С MCP", description: "Создать один раз — работает везде. Стандартный протокол. AI может автоматически обнаруживать и использовать ваши инструменты.", color: "green" },
]} />

### MCP предоставляет

- **Resources**: Данные, которые AI может читать (файлы, записи базы данных, ответы API)
- **Tools**: Действия, которые AI может выполнять (поиск, создание, обновление, удаление)
- **Prompts**: Готовые шаблоны промптов

<Callout type="info" title="prompts.chat использует MCP">
У этой платформы есть MCP-сервер! Вы можете подключить его к Claude Desktop или другим MCP-совместимым клиентам, чтобы искать и использовать промпты прямо из вашего AI-ассистента.
</Callout>

## Построение контекста: полная картина

<ContextPlayground />

## Лучшие практики

<Checklist 
  title="Чек-лист контекстной инженерии"
  items={[
    { text: "Делайте системные промпты краткими, но полными" },
    { text: "Включайте только релевантный контекст (не всё подряд)" },
    { text: "Суммаризируйте длинные разговоры" },
    { text: "Используйте RAG для доменно-специфичных знаний" },
    { text: "Давайте AI инструменты для получения данных в реальном времени" },
    { text: "Отслеживайте использование токенов, чтобы оставаться в пределах лимитов" },
    { text: "Тестируйте с граничными случаями (очень длинные входные данные и т.д.)" }
  ]}
/>

## Итоги

Контекстная инженерия — это предоставление AI правильной информации:

- **AI не имеет состояния** — включайте всё необходимое каждый раз
- **RAG** извлекает релевантные документы для дополнения промптов
- **Embeddings** обеспечивают семантический поиск (по смыслу, а не только по ключевым словам)
- **Function calling** позволяет AI использовать внешние инструменты
- **Суммаризация** управляет длинными разговорами
- **MCP** стандартизирует подключение AI к данным и инструментам

<Callout type="tip" title="Запомните">
Качество вывода AI зависит от качества предоставленного контекста. Лучший контекст = лучшие ответы.
</Callout>
