Chain of Thought (CoT) — это техника промптинга, которая значительно улучшает производительность ИИ при решении сложных задач, требующих рассуждений, путём просьбы к модели показывать свою работу шаг за шагом.

<Callout type="info" title="Покажите свою работу">
Подобно учителю математики, который просит учеников показывать решение, CoT-промптинг просит ИИ делать своё рассуждение видимым.
</Callout>

## Проблема, которую решает CoT

Модели ИИ могут испытывать трудности с многоэтапными рассуждениями, когда их просят сразу перейти к ответу.

<Compare 
  before={{ label: "Прямой ответ (часто неверный)", content: "Вопрос: Магазин продаёт яблоки по $2 за штуку. При покупке 5 и более вы получаете скидку 20%. Сколько стоят 7 яблок?\n\nОтвет: $14 ❌" }}
  after={{ label: "Chain of Thought (правильный)", content: "Вопрос: Магазин продаёт яблоки по $2 за штуку. При покупке 5 и более вы получаете скидку 20%. Сколько стоят 7 яблок?\n\nДавайте разберём это шаг за шагом:\n1. Обычная цена за яблоко: $2\n2. Количество яблок: 7\n3. Поскольку 7 ≥ 5, скидка применяется\n4. Обычная сумма: 7 × $2 = $14\n5. Скидка: 20% от $14 = $2.80\n6. Итоговая цена: $14 - $2.80 = $11.20\n\nОтвет: $11.20 ✓" }}
/>

## Базовые CoT-промпты

### Простые триггерные фразы

Добавьте одну из этих фраз к вашим промптам:

<div className="my-4 grid gap-2">
  <div className="p-3 bg-muted/50 rounded-lg font-mono text-sm">"Давайте подумаем шаг за шагом."</div>
  <div className="p-3 bg-muted/50 rounded-lg font-mono text-sm">"Обдумайте это внимательно."</div>
  <div className="p-3 bg-muted/50 rounded-lg font-mono text-sm">"Решите эту задачу методично."</div>
  <div className="p-3 bg-muted/50 rounded-lg font-mono text-sm">"Покажите своё рассуждение на каждом шаге."</div>
  <div className="p-3 bg-muted/50 rounded-lg font-mono text-sm">"Объясните ход своих мыслей."</div>
</div>

### Явный запрос шагов

<TryIt 
  title="Попробуйте Chain of Thought"
  description="Попросите ИИ решить задачу шаг за шагом."
  prompt={`Решите эту задачу:

Аренда автомобиля стоит $40 в день плюс $0.25 за милю. Если кто-то арендует автомобиль на 3 дня и проезжает 200 миль, какова общая стоимость?

Прежде чем дать окончательный ответ:
1. Определите, какая информация дана
2. Определите, что нам нужно найти
3. Спланируйте свой подход
4. Выполните каждый шаг, показывая работу
5. Проверьте свой ответ`}
/>

## Zero-Shot vs Few-Shot CoT

Существует два основных подхода к Chain of Thought промптингу, каждый с разными компромиссами между простотой и контролем.

### Zero-Shot CoT

Самый простой подход — просто добавьте триггерную фразу и позвольте модели самой определить, как рассуждать. Примеры не нужны. Это удивительно хорошо работает для многих задач, хотя у вас меньше контроля над форматом рассуждений.

<TryIt 
  compact
  title="Zero-Shot CoT"
  prompt={`Если у Джона 3 яблока и он отдаёт половину Мэри, а затем покупает ещё 4, сколько у него яблок?

Давайте подумаем шаг за шагом.`}
/>

**Пример вывода:**
```
Давайте подумаем шаг за шагом.
- У Джона изначально 3 яблока
- Половина от 3 — это 1.5, но яблоки нельзя разделить
- Если округлить вниз: Джон отдаёт 1 яблоко, оставляет 2
- После покупки ещё 4: 2 + 4 = 6 яблок

Ответ: 6 яблок
```

### Few-Shot CoT

Для более стабильных результатов покажите модели, как именно вы хотите, чтобы она рассуждала, предоставив готовые примеры. Это даёт вам контроль над стилем рассуждений, форматом и уровнем детализации. Модель будет имитировать продемонстрированный паттерн.

<TryIt 
  compact
  title="Few-Shot CoT"
  prompt={`Пример 1:
В: У пекаря 24 кекса. Она раскладывает их поровну в 4 коробки. Затем она съедает 2 кекса из одной коробки. Сколько всего кексов осталось?

О: Давайте разберём это:
- Всего кексов: 24
- Кексов в коробке: 24 ÷ 4 = 6
- После съедания 2 из одной коробки: 6 - 2 = 4 кекса в этой коробке
- Всего осталось: (3 коробки × 6) + 4 = 18 + 4 = 22 кекса

Пример 2:
В: Поезд едет со скоростью 60 миль/ч в течение 2 часов, затем 40 миль/ч в течение 3 часов. Какова средняя скорость?

О: Давайте разберём это:
- Расстояние при 60 миль/ч: 60 × 2 = 120 миль
- Расстояние при 40 миль/ч: 40 × 3 = 120 миль
- Общее расстояние: 120 + 120 = 240 миль
- Общее время: 2 + 3 = 5 часов
- Средняя скорость: 240 ÷ 5 = 48 миль/ч

Теперь решите:
В: Магазин продаёт тетради по $3 за штуку. При покупке 10 и более вы получаете скидку 25%. Сколько стоят 12 тетрадей?`}
/>

**Пример вывода:**
```
О: Давайте разберём это:
- Обычная цена: $3, Количество: 12
- Поскольку 12 ≥ 10, применяется скидка 25%
- Обычная сумма: 12 × $3 = $36
- Скидка: 25% от $36 = $9
- Итоговая цена: $36 - $9 = $27
```

## Структурированные форматы CoT

Для последовательных, воспроизводимых рассуждений используйте структурированные форматы с именованными шагами. Эти фреймворки гарантируют, что модель не пропустит важные этапы, и делают выводы более лёгкими для разбора и проверки.

### Формат BREAK

Запоминающаяся аббревиатура, которая проводит модель через полный цикл решения задачи, от понимания до проверки.

<BREAKFramework />

### Шаблон рассуждений

Более формальная структура, которая разделяет входные данные, цели и выполнение. Отлично подходит для технических задач, где нужна чёткая документация процесса решения.

<TryIt 
  compact
  title="Шаблон рассуждений"
  prompt={`Используйте этот шаблон для решения задачи:

ДАНО: [Перечислите известную информацию]
ЦЕЛЬ: [Что нам нужно найти]
ПОДХОД: [Стратегия, которую мы будем использовать]
ШАГИ:
  1. [Первый шаг с рассуждением]
  2. [Второй шаг с рассуждением]
  ...
ПРОВЕРКА: [Проверьте ответ]
ОТВЕТ: [Окончательный ответ]

Задача: Автомобиль расходует 8 литров топлива на 100 км. Если бак вмещает 45 литров, а топливо стоит $1.50 за литр, сколько стоит проехать 300 км?`}
/>

**Пример вывода:**
```
ДАНО: 8л/100км, бак 45л, $1.50/л, проехать 300км
ЦЕЛЬ: Рассчитать стоимость топлива
ПОДХОД: Необходимое топливо × стоимость литра
ШАГИ:
1. Топливо = (300 ÷ 100) × 8 = 24 литра
2. Стоимость = 24 × $1.50 = $36
ПРОВЕРКА: 24л < 45л бак ✓
ОТВЕТ: $36
```

## CoT для разных типов задач

Разные типы задач выигрывают от разных подходов CoT. Вот паттерны, оптимизированные для распространённых сценариев.

### Математические рассуждения

Математические задачи больше всего выигрывают от CoT, потому что каждый шаг строится на предыдущем. Ошибки накапливаются, поэтому показ работы помогает выявлять ошибки на ранних этапах. Модель должна чётко обозначать каждый расчёт.

<TryIt 
  compact
  title="Математика с CoT"
  prompt={`Выручка компании составила $1.2M в Q1. Она выросла на 15% в Q2, снизилась на 10% в Q3 и выросла на 25% в Q4. Какова общая годовая выручка?

Продумайте каждый квартал, чётко показывая свои расчёты.`}
/>

**Пример вывода:**
```
Q1: $1,200,000 (дано)
Q2: $1,200,000 × 1.15 = $1,380,000
Q3: $1,380,000 × 0.90 = $1,242,000
Q4: $1,242,000 × 1.25 = $1,552,500

Итого: $5,374,500
```

### Логические рассуждения

Логические задачи требуют систематического исключения и проверки гипотез. CoT помогает модели отслеживать ограничения, проверять возможности и убеждаться, что все условия выполнены. Ключ — методичное исследование, а не угадывание.

<TryIt 
  compact
  title="Логическая задача"
  prompt={`Три друга — Алиса, Боб и Кэрол — имеют разных питомцев (кошка, собака, рыбка) и разные профессии (учитель, инженер, врач).

Подсказки:
1. У Алисы нет кошки
2. У инженера есть собака
3. Боб — учитель
4. У Кэрол нет рыбки

У кого какой питомец и какая профессия? Рассуждайте систематически, проверяя гипотезы и сверяя со всеми подсказками.`}
/>

**Пример вывода:**
```
Из подсказки 3: Боб = учитель
→ Алиса и Кэрол — инженер/врач

Если Кэрол = инженер:
- У Кэрол собака (подсказка 2)
- Алиса = врач, у неё рыбка (подсказка 1)
- У Боба кошка

Проверка: Все 4 подсказки выполнены ✓
Ответ: Алиса (врач, рыбка), Боб (учитель, кошка), Кэрол (инженер, собака)
```

### Отладка кода

Отладка выигрывает от CoT, потому что это заставляет модель прослеживать выполнение, а не угадывать ошибки. Пошаговое прохождение кода с конкретными значениями делает видимым фактическое поведение и выявляет расхождения с ожидаемым поведением.

<TryIt 
  compact
  title="Отладка с CoT"
  prompt={`Эта функция должна возвращать сумму чётных чисел в списке, но она возвращает неправильные значения. Отладьте шаг за шагом, прослеживая выполнение с входными данными [2, 3, 4, 6]:

def sum_evens(numbers):
    total = 0
    for n in numbers:
        if n % 2 == 0:
            total += 1
    return total

Проследите каждый шаг, найдите ошибку и предоставьте исправление.`}
/>

**Пример вывода:**
```
Трассировка [2, 3, 4, 6]:
n=2: total += 1 → 1 (стоп, добавляем 1, а не n!)
n=3: пропуск (нечётное)
n=4: total = 2
n=6: total = 3

ОШИБКА: "total += 1" должно быть "total += n"
Ожидалось: 12, Получено: 3
Исправление: Изменить на "total += n"
```

## Self-Consistency с CoT

Для критически важных задач не полагайтесь на один путь рассуждений. Сгенерируйте несколько независимых решений и сравните результаты. Если разные подходы сходятся к одному ответу, уверенность высока. Расхождение сигнализирует о необходимости тщательной проверки.

<TryIt 
  compact
  title="Self-Consistency"
  prompt={`Решите эту задачу 3 разными способами, затем дайте окончательный ответ на основе того, какое решение кажется наиболее правильным:

Задача: У фермера есть куры и коровы. Вместе у них 30 голов и 74 ноги. Сколько кур и сколько коров у фермера?

Подход 1: Алгебра
Подход 2: Подбор
Подход 3: Логическое рассуждение

Затем сравните и дайте окончательный ответ.`}
/>

**Пример вывода:**
```
Подход 1 (Алгебра): к + р = 30, 2к + 4р = 74 → к=23, р=7
Подход 2 (Подбор): Пробуем 23/7 → 46 + 28 = 74 ✓
Подход 3 (Логика): 30 кур = 60 ног, нужно ещё 14 → 7 коров

Все согласны: 23 курицы, 7 коров
```

## CoT для принятия решений

Решения включают взвешивание компромиссов по нескольким измерениям. CoT обеспечивает систематическое рассмотрение всех релевантных факторов, а не поспешные выводы. Этот структурированный подход также документирует рассуждения для будущих справок.

<TryIt 
  compact
  title="Анализ решения"
  prompt={`Стоит ли нам переходить на микросервисную архитектуру для нашего приложения?

Контекст:
- Монолитное приложение с 50,000 строк кода
- Команда из 5 разработчиков
- 100 активных пользователей в день
- Планируется 10-кратный рост за 2 года

Продумайте это систематически:
1. Перечислите текущее состояние
2. Определите факторы для рассмотрения (размер команды, масштаб, скорость разработки, будущий рост)
3. Оцените каждый фактор как за/против
4. Дайте рекомендацию с обоснованием`}
/>

**Пример вывода:**
```
ФАКТОРЫ:
- Размер команды (5): Слишком мало для микросервисов ❌
- Масштаб (100 DAU): Нет необходимости в масштабировании ❌  
- Скорость: Монолит = быстрее итерации ❌
- Будущий рост: Неопределённые сроки ⚠️

ВЗВЕШИВАНИЕ: 3 сильных против, 1 слабый за

РЕКОМЕНДАЦИЯ: Остаться на монолите, использовать чёткие 
границы модулей для облегчения перехода в будущем.
```

## Когда использовать CoT

<div className="my-6 grid md:grid-cols-2 gap-4">
  <div className="border rounded-lg bg-green-50/50 dark:bg-green-950/20 border-green-200 dark:border-green-900">
    <p className="text-sm font-semibold text-green-700 dark:text-green-400 px-4 pt-3 flex items-center gap-2 m-0!"><IconCheck className="h-4 w-4" /> Используйте CoT для</p>
    <div className="text-sm p-4 pt-2 space-y-1">
      <p className="m-0!">**Математических задач** — Уменьшает ошибки вычислений</p>
      <p className="m-0!">**Логических головоломок** — Предотвращает пропуск шагов</p>
      <p className="m-0!">**Сложного анализа** — Организует мышление</p>
      <p className="m-0!">**Отладки кода** — Прослеживает выполнение</p>
      <p className="m-0!">**Принятия решений** — Взвешивает компромиссы</p>
    </div>
  </div>
  <div className="border rounded-lg bg-red-50/50 dark:bg-red-950/20 border-red-200 dark:border-red-900">
    <p className="text-sm font-semibold text-red-700 dark:text-red-400 px-4 pt-3 flex items-center gap-2 m-0!"><IconX className="h-4 w-4" /> Пропустите CoT для</p>
    <div className="text-sm p-4 pt-2 space-y-1">
      <p className="m-0!">**Простых вопросов и ответов** — Ненужные накладные расходы</p>
      <p className="m-0!">**Творческого письма** — Может ограничивать креативность</p>
      <p className="m-0!">**Поиска фактов** — Рассуждения не нужны</p>
      <p className="m-0!">**Перевода** — Прямая задача</p>
      <p className="m-0!">**Суммаризации** — Обычно проста</p>
    </div>
  </div>
</div>

## Ограничения CoT

Хотя CoT и мощный инструмент, это не универсальное решение. Понимание его ограничений помогает применять его правильно.

1. **Увеличенное использование токенов** — Больше вывода означает более высокие затраты
2. **Не всегда нужен** — Простые задачи не выигрывают
3. **Может быть многословным** — Возможно, придётся просить краткости
4. **Рассуждения могут быть ошибочными** — CoT не гарантирует правильность

## Резюме

<Callout type="tip" title="Ключевые выводы">
CoT значительно улучшает сложные рассуждения, делая неявные шаги явными. Используйте его для математики, логики, анализа и отладки. Компромисс: лучшая точность за большее количество токенов.
</Callout>

<Quiz 
  question="Когда НЕ следует использовать Chain of Thought промптинг?"
  options={[
    "Математические задачи, требующие нескольких шагов",
    "Простые фактические вопросы вроде 'Какая столица Франции?'",
    "Отладка кода со сложной логикой",
    "Анализ бизнес-решения"
  ]}
  correctIndex={1}
  explanation="Chain of Thought добавляет ненужные накладные расходы для простых вопросов и ответов. Лучше приберечь его для сложных задач рассуждения, таких как математика, логические головоломки, отладка кода и анализ, где показ работы улучшает точность."
/>

В следующей главе мы рассмотрим few-shot learning — обучение модели через примеры.
