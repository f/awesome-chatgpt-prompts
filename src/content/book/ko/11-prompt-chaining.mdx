프롬프트 체이닝은 복잡한 작업을 더 단순한 프롬프트의 연속으로 분해하여, 각 단계의 출력이 다음 단계의 입력으로 전달되는 기법입니다. 이 기술은 신뢰성을 크게 향상시키며, 단일 프롬프트로는 불가능한 정교한 워크플로우를 가능하게 합니다.

<Callout type="tip" title="조립 라인처럼 생각하세요">
공장의 조립 라인이 제조 과정을 전문화된 작업장으로 분리하는 것처럼, 프롬프트 체이닝은 AI 작업을 전문화된 단계로 분해합니다. 각 단계는 한 가지 일을 잘 수행하며, 결합된 출력은 모든 것을 한 번에 처리하려는 것보다 훨씬 더 나은 결과를 제공합니다.
</Callout>

## 왜 프롬프트를 체이닝해야 할까요?

단일 프롬프트는 복잡한 작업에서 어려움을 겪습니다. 한 번에 너무 많은 것을 처리하려 하기 때문입니다. AI는 동시에 이해하고, 분석하고, 계획하고, 생성해야 하므로 오류와 일관성 문제가 발생합니다.

<div className="my-6 grid md:grid-cols-2 gap-4">
  <div className="border rounded-lg bg-red-50/50 dark:bg-red-950/20 border-red-200 dark:border-red-900">
    <p className="text-sm font-semibold text-red-700 dark:text-red-400 px-4 pt-3 flex items-center gap-2 m-0!"><IconX className="h-4 w-4" /> 단일 프롬프트의 한계</p>
    <div className="text-sm p-4 pt-2 space-y-1">
      <p className="m-0!">다단계 추론이 혼란스러워짐</p>
      <p className="m-0!">서로 다른 "사고 모드"가 충돌</p>
      <p className="m-0!">복잡한 출력의 일관성 부족</p>
      <p className="m-0!">품질 관리의 기회 없음</p>
    </div>
  </div>
  <div className="border rounded-lg bg-green-50/50 dark:bg-green-950/20 border-green-200 dark:border-green-900">
    <p className="text-sm font-semibold text-green-700 dark:text-green-400 px-4 pt-3 flex items-center gap-2 m-0!"><IconCheck className="h-4 w-4" /> 체이닝으로 해결</p>
    <div className="text-sm p-4 pt-2 space-y-1">
      <p className="m-0!">각 단계가 하나의 작업에 집중</p>
      <p className="m-0!">각 모드에 맞는 전문화된 프롬프트</p>
      <p className="m-0!">단계 사이에서 검증 가능</p>
      <p className="m-0!">개별 단계의 디버깅 및 개선 가능</p>
    </div>
  </div>
</div>

## 기본 체이닝 패턴

가장 단순한 체인은 한 프롬프트의 출력을 다음 프롬프트로 직접 전달합니다. 각 단계는 명확하고 집중된 목적을 가집니다.

<div className="my-6 flex items-center justify-center gap-3 p-6 bg-muted/30 rounded-lg overflow-x-auto">
  <div className="flex flex-col items-center">
    <div className="px-4 py-3 bg-blue-100 dark:bg-blue-900/50 border border-blue-200 dark:border-blue-800 rounded-lg text-center">
      <p className="text-sm font-medium text-blue-700 dark:text-blue-300 m-0!">프롬프트 1</p>
      <p className="text-xs text-blue-600 dark:text-blue-400 m-0!">(추출)</p>
    </div>
    <p className="text-xs text-muted-foreground mt-1 m-0!">입력</p>
  </div>
  <div className="text-blue-400 dark:text-blue-500">→</div>
  <div className="flex flex-col items-center">
    <div className="px-4 py-3 bg-purple-100 dark:bg-purple-900/50 border border-purple-200 dark:border-purple-800 rounded-lg text-center">
      <p className="text-sm font-medium text-purple-700 dark:text-purple-300 m-0!">프롬프트 2</p>
      <p className="text-xs text-purple-600 dark:text-purple-400 m-0!">(분석)</p>
    </div>
    <p className="text-xs text-muted-foreground mt-1 m-0!">중간 결과</p>
  </div>
  <div className="text-purple-400 dark:text-purple-500">→</div>
  <div className="flex flex-col items-center">
    <div className="px-4 py-3 bg-green-100 dark:bg-green-900/50 border border-green-200 dark:border-green-800 rounded-lg text-center">
      <p className="text-sm font-medium text-green-700 dark:text-green-300 m-0!">프롬프트 3</p>
      <p className="text-xs text-green-600 dark:text-green-400 m-0!">(생성)</p>
    </div>
    <p className="text-xs text-muted-foreground mt-1 m-0!">출력</p>
  </div>
</div>

<Callout type="info" title="ETG 패턴">
가장 일반적인 체인 패턴은 **추출(Extract) → 변환(Transform) → 생성(Generate)**입니다. 먼저 원시 데이터를 추출하고, 목적에 맞게 재구성한 다음, 최종 출력을 생성합니다. 이 패턴은 거의 모든 콘텐츠 작업에 적용됩니다.
</Callout>

## 체인 유형

각기 다른 작업에는 서로 다른 체인 아키텍처가 필요합니다. 워크플로우에 맞는 패턴을 선택하세요.

<ChainFlowDemo />

### 순차 체인

가장 직관적인 패턴입니다: 각 단계가 이전 단계에 의존합니다. 각 주자가 바톤을 다음 주자에게 전달하는 릴레이 경주라고 생각하세요.

<ChainExample 
  type="sequential"
  steps={[
    { step: "1단계: 추출", prompt: "다음 텍스트에서 모든 날짜, 이름, 숫자를 추출하세요: [텍스트]", output: '{ dates: ["2024-01-15", "2024-02-20"], names: ["김철수", "에이스 주식회사"], numbers: [15000, 42] }' },
    { step: "2단계: 분석", prompt: "이 추출된 데이터를 바탕으로: [step1_output], 관계와 패턴을 식별하세요.", output: '{ patterns: ["월간 회의 일정 확인"], relationships: ["김철수는 에이스 주식회사에서 근무"] }' },
    { step: "3단계: 생성", prompt: "이 패턴을 사용하여: [step2_output], 가장 중요한 발견사항을 강조하는 요약 보고서를 작성하세요.", output: "요약 보고서: 문서 분석 결과, 김철수와 에이스 주식회사 간의 비즈니스 관계가 확인되었으며, 월간 정기 회의가 예정되어 있습니다..." }
  ]}
/>

### 병렬 체인

동일한 입력에 대해 여러 관점이 필요할 때, 프롬프트를 병렬로 실행하고 결과를 병합합니다. 이는 순차 체인보다 빠르며 더 풍부한 분석을 제공합니다.

<ChainExample 
  type="parallel"
  steps={[
    { step: "입력", prompt: "제품 리뷰 텍스트", output: '"이 이어버드 정말 좋아요! 배터리가 오래가고 케이스의 디스플레이가 너무 편리해요. 출퇴근할 때 딱이에요."' },
    { step: "분기 A: 감성", prompt: "감성 분석: [텍스트]", output: '{ sentiment: "긍정적", score: 0.85 }' },
    { step: "분기 B: 기능", prompt: "언급된 기능 추출: [텍스트]", output: '{ features: ["배터리", "디스플레이"] }' },
    { step: "분기 C: 페르소나", prompt: "사용자 페르소나 식별: [텍스트]", output: '{ persona: "출퇴근자" }' },
    { step: "병합", prompt: "분석 결과를 통합 보고서로 결합", output: "통합 보고서: 배터리와 디스플레이를 강조한 출퇴근자의 긍정적 리뷰." }
  ]}
/>

### 조건부 체인

분류에 따라 입력을 다른 경로로 라우팅합니다. 이는 AI가 먼저 입력을 분류한 다음, 각 카테고리를 다르게 처리하는 의사결정 트리와 같습니다.

<ChainExample 
  type="conditional"
  steps={[
    { step: "입력 분류", prompt: "이 고객 메시지를 분류하세요: 불만, 질문, 피드백, 또는 기타.\n\n메시지: [텍스트]", output: '{ classification: "불만", confidence: 0.92 }' },
    { step: "경로: 질문 (건너뜀)", prompt: "필요한 정보 식별", output: "건너뜀 - 입력이 불만으로 분류됨" },
    { step: "경로: 불만", prompt: "문제와 심각도 식별: [텍스트]", output: '{ issue: "배송 지연", severity: "중간" }' },
    { step: "응답 생성", prompt: "공감적인 응답과 해결책 생성: [분석]", output: "고객님께, 배송 지연에 대해 진심으로 사과드립니다. 주문이 신속 처리되었습니다..." }
  ]}
/>

### 반복 체인

품질 기준을 충족할 때까지 출력을 계속 개선합니다. AI는 만족할 때까지 또는 최대 반복 횟수에 도달할 때까지 생성하고, 평가하고, 개선하는 루프를 반복합니다.

<Callout type="warning" title="반복 제한 설정">
무한 루프를 방지하고 비용을 제어하기 위해 항상 최대 반복 횟수(일반적으로 3-5회)를 설정하세요. 수확 체감의 법칙이 적용됩니다: 대부분의 개선은 처음 2-3회 반복에서 발생합니다.
</Callout>

<ChainExample 
  type="iterative"
  steps={[
    { step: "초안 생성", prompt: "[무선 이어버드]에 대한 제품 설명을 작성하세요", output: "이 무선 이어버드는 좋은 음질과 편안한 착용감으로 일상적인 사용에 적합합니다." },
    { step: "평가 (점수: 5)", prompt: "이 설명을 1-10점으로 평가하세요: 명확성, 설득력, 정확성.\n\n설명: [현재_초안]", output: '{ score: 5, improvements: ["구체적인 기능 추가", "감성적 혜택 포함", "배터리 수명 언급", "행동 촉구 추가"] }' },
    { step: "초안 개선", prompt: "이 피드백을 바탕으로 설명을 개선하세요:\n\n현재: [현재_초안]\n피드백: [개선사항]", output: "프리미엄 무선 이어버드로 맑고 선명한 오디오를 경험하세요. 30시간 배터리 수명, 액티브 노이즈 캔슬링, 하루 종일 편안한 인체공학적 디자인을 갖추고 있습니다. 음악 애호가와 전문가 모두에게 완벽합니다. 지금 주문하고 청취 경험을 바꿔보세요." },
    { step: "평가 (점수: 8)", prompt: "이 설명을 1-10점으로 평가하세요: 명확성, 설득력, 정확성.\n\n설명: [개선된_초안]", output: '{ score: 8, improvements: ["사소함: 보증 정보 추가 가능"] }\n\n✓ 점수 >= 8: 루프 종료' }
  ]}
/>

## 일반적인 체인 패턴

이 검증된 패턴들은 일반적인 문제를 해결합니다. 시작점으로 사용하고 필요에 맞게 조정하세요.

### 추출 → 변환 → 생성

콘텐츠 처리의 핵심 패턴입니다. 데이터를 추출하고, 재구성한 다음, 새로운 것을 생성합니다.

<div className="mb-4 p-3 rounded-lg bg-blue-50/50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800">
  <p className="text-xs font-semibold text-blue-700 dark:text-blue-300 mb-1 m-0!">적합한 용도</p>
  <p className="text-sm text-blue-600 dark:text-blue-400 m-0!">문서 요약, 보고서 생성, 콘텐츠 재활용, 데이터-내러티브 변환</p>
</div>

<ChainExample 
  type="sequential"
  steps={[
    { step: "추출", prompt: "이 문서에서 추출하세요:\n- 주요 주제\n- 핵심 논점 (목록)\n- 근거 자료 (목록)\n- 결론\nJSON으로 반환하세요.", output: '{ "topic": "기후 변화 영향", "arguments": ["기온 상승", "해수면 상승"], "evidence": ["NASA 데이터", "IPCC 보고서"], "conclusions": ["긴급한 조치 필요"] }' },
    { step: "변환", prompt: "[비즈니스 임원]을 위해 이 정보를 재구성하세요:\n[추출된_데이터]\n초점: 경제적 영향\n제거: 기술 용어", output: '{ "summary": "비즈니스에 대한 기후 리스크", "key_points": ["공급망 교란", "보험 비용 상승"], "action_items": ["취약점 평가", "적응 전략 계획"] }' },
    { step: "생성", prompt: "이 재구성된 정보를 사용하여 [임원 브리프]를 작성하세요:\n[변환된_데이터]\n톤: 전문적\n길이: 200단어", output: "임원 브리프: 기후 변화는 우리 비즈니스에 중대한 운영 리스크를 제시합니다. 주요 우려 사항으로는 극단적 기상 현상으로 인한 공급망 교란과 보험료 상승이 있습니다. 시설 취약성에 대한 즉각적인 평가와 적응 전략 개발을 권장합니다..." }
  ]}
/>

### 분석 → 계획 → 실행

코드 리팩토링, 프로젝트 계획, 또는 행동 전에 이해가 필요한 모든 작업에 완벽합니다.

<div className="mb-4 p-3 rounded-lg bg-purple-50/50 dark:bg-purple-950/20 border border-purple-200 dark:border-purple-800">
  <p className="text-xs font-semibold text-purple-700 dark:text-purple-300 mb-1 m-0!">적합한 용도</p>
  <p className="text-sm text-purple-600 dark:text-purple-400 m-0!">코드 리팩토링, 프로젝트 계획, 문제 해결, 전략적 의사결정, 복잡한 문제 해결</p>
</div>

<ChainExample 
  type="sequential"
  steps={[
    { step: "분석", prompt: "이 코드베이스 구조를 분석하고 식별하세요:\n- 아키텍처 패턴\n- 주요 컴포넌트\n- 의존성\n- 잠재적 문제\n[코드]", output: '{ "pattern": "MVC", "components": ["UserController", "AuthService", "Database"], "dependencies": ["express", "mongoose"], "issues": ["입력 검증 없음", "하드코딩된 시크릿"] }' },
    { step: "계획", prompt: "이 분석을 바탕으로 리팩토링 계획을 작성하세요:\n[분석_출력]\n목표: 보안 개선\n제약: 호환성 유지", output: '{ "steps": ["1. 입력 검증 미들웨어 추가", "2. 시크릿을 환경 변수로 이동", "3. 속도 제한 추가"], "priority": "높음", "estimated_time": "4시간" }' },
    { step: "실행", prompt: "이 계획의 1단계를 구현하세요:\n[계획_출력]\n설명과 함께 리팩토링된 코드를 보여주세요.", output: "// 검증 미들웨어 추가\nconst validateInput = (req, res, next) => {\n  const { email, password } = req.body;\n  if (!email || !isValidEmail(email)) {\n    return res.status(400).json({ error: 'Invalid email' });\n  }\n  next();\n};" }
  ]}
/>

### 생성 → 비평 → 개선

자기 개선 루프입니다. 콘텐츠를 생성하고, AI가 비판적으로 평가한 다음, 그 피드백을 바탕으로 개선합니다. 이는 전문 작가와 편집자가 함께 일하는 방식을 모방합니다.

<div className="mb-4 p-3 rounded-lg bg-green-50/50 dark:bg-green-950/20 border border-green-200 dark:border-green-800">
  <p className="text-xs font-semibold text-green-700 dark:text-green-300 mb-1 m-0!">적합한 용도</p>
  <p className="text-sm text-green-600 dark:text-green-400 m-0!">마케팅 카피, 창작 글쓰기, 이메일 초안, 프레젠테이션, 수정이 도움이 되는 모든 콘텐츠</p>
</div>

<ChainExample 
  type="iterative"
  steps={[
    { step: "생성", prompt: "[바쁜 직장인]을 타겟으로 한 [피트니스 앱]의 마케팅 이메일을 작성하세요.", output: "제목: 빠르게 건강해지세요!\n\n안녕하세요! 저희 앱은 운동을 도와줍니다. 오늘 다운로드하고 피트니스 여정을 시작하세요. 감사합니다!" },
    { step: "비평", prompt: "마케팅 전문가로서 이 이메일을 비평하세요:\n[생성된_이메일]\n평가: 제목, 후크, 가치 제안, CTA, 톤\n각각 1-10점으로 점수를 매기세요.", output: '{ "subject_line": 4, "hook": 3, "value_proposition": 2, "cta": 5, "tone": 4, "feedback": "너무 일반적, 구체적 혜택 없음, 긴급성 부족" }' },
    { step: "개선", prompt: "이 피드백을 반영하여 이메일을 다시 작성하세요:\n원본: [생성된_이메일]\n비평: [비평_출력]\n가장 낮은 점수의 요소에 집중하세요.", output: "제목: 점심시간 15분 운동\n\n바쁜 일정? 저희도 알아요. 저희 앱은 시간이 없는 직장인을 위해 설계된 과학적으로 검증된 운동을 제공합니다. 하루 15분 만에 건강을 변화시킨 50,000명 이상의 직장인들과 함께하세요. 지금 무료 체험을 시작하세요—미래의 당신이 감사할 것입니다." },
    { step: "최종 점수", prompt: "개선된 이메일을 다시 평가하세요.", output: '{ "subject_line": 8, "hook": 8, "value_proposition": 9, "cta": 8, "tone": 9, "improvement": "총 +23점 향상" }' }
  ]}
/>

## 체인 구현

실험을 위해 수동으로 체인을 구현하거나, 프로덕션 시스템을 위해 프로그래밍 방식으로 구현할 수 있습니다. 간단하게 시작하고 필요에 따라 복잡성을 추가하세요.

### 수동 체이닝

복사-붙여넣기 방식은 프로토타이핑과 실험에 완벽합니다. 각 프롬프트를 수동으로 실행하고, 출력을 검토한 다음, 다음 프롬프트에 붙여넣습니다.

<CodeEditor 
  language="python"
  filename="manual_chain.py"
  code={`# Pseudocode for manual chaining
step1_output = call_ai("Extract entities from: " + input_text)
step2_output = call_ai("Analyze relationships: " + step1_output)
final_output = call_ai("Generate report: " + step2_output)`}
/>

### 프로그래밍 방식 체이닝

프로덕션 시스템에서는 코드로 체인을 자동화합니다. 이를 통해 오류 처리, 로깅, 애플리케이션과의 통합이 가능합니다.

<CodeEditor 
  language="python"
  filename="chain.py"
  code={`def analysis_chain(document):
    # Step 1: Summarize
    summary = call_ai(f"""
        Summarize the key points of this document in 5 bullets:
        {document}
    """)
    
    # Step 2: Extract entities
    entities = call_ai(f"""
        Extract named entities (people, organizations, locations) 
        from this summary. Return as JSON.
        {summary}
    """)
    
    # Step 3: Generate insights
    insights = call_ai(f"""
        Based on this summary and entities, generate 3 actionable 
        insights for a business analyst.
        Summary: {summary}
        Entities: {entities}
    """)
    
    return {
        "summary": summary,
        "entities": json.loads(entities),
        "insights": insights
    }`}
/>

### 체인 템플릿 사용

재사용성과 쉬운 수정을 위해 체인을 구성 파일로 정의합니다. 이렇게 하면 프롬프트 로직과 애플리케이션 코드가 분리됩니다.

<CodeEditor 
  language="yaml"
  filename="chain_template.yaml"
  code={`name: "Document Analysis Chain"
steps:
  - name: "extract"
    prompt: |
      Extract key information from this document:
      {input}
      Return JSON with: topics, entities, dates, numbers
    
  - name: "analyze"
    prompt: |
      Analyze this extracted data for patterns:
      {extract.output}
      Identify: trends, anomalies, relationships
    
  - name: "report"
    prompt: |
      Generate an executive summary based on:
      Data: {extract.output}
      Analysis: {analyze.output}
      Format: 3 paragraphs, business tone`}
/>

## 체인에서의 오류 처리

체인은 어느 단계에서든 실패할 수 있습니다. 검증, 재시도, 폴백을 구축하여 체인을 견고하게 만드세요.

<ChainErrorDemo />

<Callout type="warning" title="쓰레기가 들어가면 쓰레기가 나온다">
한 단계에서 잘못된 출력이 나오면 이후의 모든 단계가 영향을 받습니다. 중요한 중간 결과는 항상 다음 단계로 전달하기 전에 검증하세요.
</Callout>

### 단계 간 검증

구조화된 데이터를 생성하는 모든 단계 후에 검증 단계를 추가합니다. 이렇게 하면 오류가 연쇄적으로 발생하기 전에 조기에 잡을 수 있습니다.

<ValidationDemo />

### 폴백 체인

기본 접근 방식이 실패할 때, 더 단순한 백업을 준비해 두세요. 기능을 신뢰성과 교환합니다.

<FallbackDemo />

## 체인 최적화

체인이 작동하면, 속도, 비용, 신뢰성을 위해 최적화합니다. 이들은 종종 서로 트레이드오프 관계에 있습니다.

<div className="my-6 grid md:grid-cols-3 gap-4">
  <div className="border rounded-lg bg-blue-50/50 dark:bg-blue-950/20 border-blue-200 dark:border-blue-900 p-4">
    <p className="text-sm font-semibold text-blue-700 dark:text-blue-400 mb-2 m-0!">지연 시간 줄이기</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">독립적인 단계 병렬화</p>
      <p className="m-0!">중간 결과 캐싱</p>
      <p className="m-0!">간단한 단계에 작은 모델 사용</p>
      <p className="m-0!">유사한 작업 일괄 처리</p>
    </div>
  </div>
  <div className="border rounded-lg bg-green-50/50 dark:bg-green-950/20 border-green-200 dark:border-green-900 p-4">
    <p className="text-sm font-semibold text-green-700 dark:text-green-400 mb-2 m-0!">비용 줄이기</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">분류에 저렴한 모델 사용</p>
      <p className="m-0!">루프에서 반복 제한</p>
      <p className="m-0!">가능할 때 조기 종료</p>
      <p className="m-0!">반복 쿼리 캐싱</p>
    </div>
  </div>
  <div className="border rounded-lg bg-purple-50/50 dark:bg-purple-950/20 border-purple-200 dark:border-purple-900 p-4">
    <p className="text-sm font-semibold text-purple-700 dark:text-purple-400 mb-2 m-0!">신뢰성 향상</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">단계 사이에 검증 추가</p>
      <p className="m-0!">재시도 로직 포함</p>
      <p className="m-0!">중간 결과 로깅</p>
      <p className="m-0!">폴백 경로 구현</p>
    </div>
  </div>
</div>

## 실제 체인 예제

완전한 프로덕션 체인을 살펴보겠습니다. 이 콘텐츠 파이프라인은 원시 아이디어를 다듬어진 기사 패키지로 변환합니다.

### 콘텐츠 파이프라인 체인

<ContentPipelineDemo />

## 요약

프롬프트 체이닝은 불가능한 작업을 달성 가능한 단계로 분해하여 AI가 성취할 수 있는 것을 변화시킵니다.

<div className="my-6 grid md:grid-cols-2 gap-4">
  <div className="border rounded-lg bg-amber-50/50 dark:bg-amber-950/20 border-amber-200 dark:border-amber-900 p-4">
    <p className="text-sm font-semibold text-amber-700 dark:text-amber-400 mb-2 m-0!">체이닝으로 가능한 것</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">복잡한 다단계 워크플로우</p>
      <p className="m-0!">전문화를 통한 더 높은 품질</p>
      <p className="m-0!">더 나은 오류 처리와 검증</p>
      <p className="m-0!">모듈화된 재사용 가능한 프롬프트 컴포넌트</p>
    </div>
  </div>
  <div className="border rounded-lg bg-cyan-50/50 dark:bg-cyan-950/20 border-cyan-200 dark:border-cyan-900 p-4">
    <p className="text-sm font-semibold text-cyan-700 dark:text-cyan-400 mb-2 m-0!">핵심 원칙</p>
    <div className="text-sm space-y-1">
      <p className="m-0!">복잡한 작업을 단순한 단계로 분해</p>
      <p className="m-0!">단계 간 명확한 인터페이스 설계</p>
      <p className="m-0!">중간 출력 검증</p>
      <p className="m-0!">오류 처리와 폴백 구축</p>
      <p className="m-0!">제약 조건에 맞게 최적화</p>
    </div>
  </div>
</div>

<Callout type="tip" title="간단하게 시작하세요">
2-3단계의 순차 체인으로 시작하세요. 복잡성을 추가하기 전에 안정적으로 작동하도록 만드세요. 대부분의 작업은 정교한 체인 아키텍처가 필요하지 않습니다.
</Callout>

<Quiz 
  question="단일 복잡한 프롬프트 대비 프롬프트 체이닝의 주요 장점은 무엇인가요?"
  options={[
    "전체적으로 더 적은 토큰을 사용한다",
    "실행 속도가 더 빠르다",
    "각 단계가 전문화되어 품질이 향상되고 오류 처리가 가능해진다",
    "계획이 덜 필요하다"
  ]}
  correctIndex={2}
  explanation="프롬프트 체이닝은 복잡한 작업을 전문화된 단계로 분해합니다. 각 단계는 한 가지 일에 집중할 수 있고, 중간 결과를 검증할 수 있으며, 오류를 잡아서 재시도할 수 있고, 전문화를 통해 전반적인 품질이 향상됩니다."
/>

다음 장에서는 멀티모달 프롬프팅: 이미지, 오디오 및 기타 비텍스트 콘텐츠 작업에 대해 살펴보겠습니다.
